数据结构（C语言版）（第2版）课后习题答案李冬梅2015.3目录第第第第第第第第1章绪论......................................................................................................................12章线性表..................................................................................................................53章栈和队列............................................................................................................134章串、数组和广义表.............................................................................................265章树和二叉树.........................................................................................................336章图........................................................................................................................427章查找....................................................................................................................548章排序....................................................................................................................65II第1章绪论1．简述下列概念：数据、数据元素、数据项、数据对象、数据结构、逻辑结构、存储结构、抽象数据类型。答案：数据：是客观事物的符号表示，指所有能输入到计算机中并被计算机程序处理的符号的总称。如数学计算中用到的整数和实数，文本编辑所用到的字符串，多媒体程序处理的图形、图像、声音、动画等通过特殊编码定义后的数据。数据元素：是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。在有些情况下，数据元素也称为元素、结点、记录等。数据元素用于完整地描述一个对象，如一个学生记录，树中棋盘的一个格局（状态）、图中的一个顶点等。数据项：是组成数据元素的、有独立含义的、不可分割的最小单位。例如，学生基本信息表中的学号、姓名、性别等都是数据项。数据对象：是性质相同的数据元素的集合，是数据的一个子集。例如：整数数据对象是集合N={0，±1，±2，„}，字母字符数据对象是集合C={‘A’，‘B’，„，‘Z’，‘a’，‘b’，„，‘z’}，学生基本信息表也可是一个数据对象。数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。换句话说，数据结构是带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系。逻辑结构：从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此，数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。存储结构：数据对象在计算机中的存储表示，也称为物理结构。抽象数据类型：由用户定义的，表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称。具体包括三部分：数据对象、数据对象上关系的集合和对数据对象的基本操作的集合。2．试举一个数据结构的例子，叙述其逻辑结构和存储结构两方面的含义和相互关系。答案：例如有一张学生基本信息表，包括学生的学号、姓名、性别、籍贯、专业等。每个学生基本信息记录对应一个数据元素，学生记录按顺序号排列，形成了学生基本信息记录的线性序列。对于整个表来说，只有一个开始结点(它的前面无记录)和一个终端结点(它的后面无记录)，其他的结点则各有一个也只有一个直接前趋和直接后继。学生记录之间的这种关系就确定了学生表的逻辑结构，即线性结构。这些学生记录在计算机中的存储表示就是存储结构。如果用连续的存储单元(如用数组表示)来存放这些记录，则称为顺序存储结构；如果存储单元不连续，而是随机存放各个记录，然后用指针进行链接，则称为链式存储结构。即相同的逻辑结构，可以对应不同的存储结构。3．简述逻辑结构的四种基本关系并画出它们的关系图。1答案：（1）集合结构数据元素之间除了“属于同一集合”的关系外，别无其他关系。例如，确定一名学生是否为班级成员，只需将班级看做一个集合结构。（2）线性结构数据元素之间存在一对一的关系。例如，将学生信息数据按照其入学报到的时间先后顺序进行排列，将组成一个线性结构。（3）树结构数据元素之间存在一对多的关系。例如，在班级的管理体系中，班长管理多个组长，每位组长管理多名组员，从而构成树形结构。（4）图结构或网状结构数据元素之间存在多对多的关系。例如，多位同学之间的朋友关系，任何两位同学都可以是朋友，从而构成图形结构或网状结构。其中树结构和图结构都属于非线性结构。四类基本逻辑结构关系图4．存储结构由哪两种基本的存储方法实现？答案：（1）顺序存储结构顺序存储结构是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，通常借助程序设计语言的数组类型来描述。（2）链式存储结构顺序存储结构要求所有的元素依次存放在一片连续的存储空间中，而链式存储结构，无需占用一整块存储空间。但为了表示结点之间的关系，需要给每个结点附加指针字段，用于存放后继元素的存储地址。所以链式存储结构通常借助于程序设计语言的指针类型来描述。5．选择题（1）在数据结构中，从逻辑上可以把数据结构分成（）。A．动态结构和静态结构B．紧凑结构和非紧凑结构2C．线性结构和非线性结构D．内部结构和外部结构答案：C（2）与数据元素本身的形式、内容、相对位置、个数无关的是数据的（）。A．存储结构B．存储实现C．逻辑结构D．运算实现答案：C（3）通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着（）。A．数据具有同一特点B．不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致C．每个数据元素都一样D．数据元素所包含的数据项的个数要相等答案：B（4）以下说法正确的是（）。A．数据元素是数据的最小单位B．数据项是数据的基本单位C．数据结构是带有结构的各数据项的集合D．一些表面上很不相同的数据可以有相同的逻辑结构答案：D解释：数据元素是数据的基本单位，数据项是数据的最小单位，数据结构是带有结构的各数据元素的集合。（5）算法的时间复杂度取决于（）。A．问题的规模答案：D解释：算法的时间复杂度不仅与问题的规模有关，还与问题的其他因素有关。如某些排序的算法，其执行时间与待排序记录的初始状态有关。为此，有时会对算法有最好、最坏以及平均时间复杂度的评价。（6）以下数据结构中，（）是非线性数据结构A．树B．字符串C．队列D．栈答案：A6．试分析下面各程序段的时间复杂度。（1）x=90; y=100;while(y>0)if(x>100){x=x-10;y--;}else x++;答案：O(1)解释：程序的执行次数为常数阶。3B．待处理数据的初态D．A和BC．计算机的配置（2）for (i=0; i<n; i++)for (j=0; j<m; j++)a[i][j]=0;答案：O(m*n)解释：语句a[i][j]=0;的执行次数为m*n。（3）s=0;for i=0; i<n; i++)for(j=0; j<n; j++)s+=B[i][j];sum=s;2答案：O(n)解释：语句s+=B[i][j];的执行次数为n。（4）i=1;while(i<=n)i=i*3;答案：O(log3n)解释：语句i=i*3;的执行次数为log3n。（5）x=0;for(i=1; i<n; i++)for (j=1; j<=n-i; j++)x++;2答案：O(n)解释：语句x++;的执行次数为n-1+n-2+„„＋1= n(n-1)/2。（6）x=n; //n>1y=0;while(x≥(y+1)* (y+1))y++;答案：O(n)解释：语句y++;的执行次数为n。24第2章线性表1．选择题（1）顺序表中第一个元素的存储地址是100，每个元素的长度为2，则第5个元素的地址是（）。A．110B．108C．100D．120答案：B解释：顺序表中的数据连续存储，所以第5个元素的地址为：100+2*4=108。（2）在n个结点的顺序表中，算法的时间复杂度是O(1)的操作是（）。A．访问第i个结点（1≤i≤n）和求第i个结点的直接前驱（2≤i≤n）B．在第i个结点后插入一个新结点（1≤i≤n）C．删除第i个结点（1≤i≤n）D．将n个结点从小到大排序答案：A解释：在顺序表中插入一个结点的时间复杂度都是O(n2)，排序的时间复杂度为O(n2)或O(nlog2n)。顺序表是一种随机存取结构，访问第i个结点和求第i个结点的直接前驱都可以直接通过数组的下标直接定位，时间复杂度是O(1)。（3）向一个有127个元素的顺序表中插入一个新元素并保持原来顺序不变，平均要移动的元素个数为（）。A．8 B．63.5 C．63D．7答案：B解释：平均要移动的元素个数为：n/2。（4）链接存储的存储结构所占存储空间（）。A．分两部分，一部分存放结点值，另一部分存放表示结点间关系的指针B．只有一部分，存放结点值C．只有一部分，存储表示结点间关系的指针D．分两部分，一部分存放结点值，另一部分存放结点所占单元数答案：A（5）线性表若采用链式存储结构时，要求内存中可用存储单元的地址（）。A．必须是连续的B．部分地址必须是连续的C．一定是不连续的D．连续或不连续都可以答案：D（6）线性表Ｌ在（）情况下适用于使用链式结构实现。A．需经常修改Ｌ中的结点值Ｂ．需不断对Ｌ进行删除插入C．Ｌ中含有大量的结点Ｄ．Ｌ中结点结构复杂答案：B5解释：链表最大的优点在于插入和删除时不需要移动数据，直接修改指针即可。（7）单链表的存储密度（）。A．大于1B．等于1C．小于1D．不能确定答案：C解释：存储密度是指一个结点数据本身所占的存储空间和整个结点所占的存储空间之比，假设单链表一个结点本身所占的空间为D，指针域所占的空间为N，则存储密度为：D/(D+N)，一定小于1。（8）将两个各有n个元素的有序表归并成一个有序表，其最少的比较次数是（）。A．nB．2n-1 C．2n D．n-1答案：A解释：当第一个有序表中所有的元素都小于（或大于）第二个表中的元素，只需要用第二个表中的第一个元素依次与第一个表的元素比较，总计比较n次。（9）在一个长度为n的顺序表中，在第i个元素（1≤i≤n+1）之前插入一个新元素时须向后移动（）个元素。A．n-iB．n-i+1C．n-i-1 D．I答案：B(10)线性表L=(a1，a2,„„an)，下列说法正确的是（）。A．每个元素都有一个直接前驱和一个直接后继B．线性表中至少有一个元素C．表中诸元素的排列必须是由小到大或由大到小D．除第一个和最后一个元素外，其余每个元素都有一个且仅有一个直接前驱和直接后继。答案：D(11)创建一个包括n个结点的有序单链表的时间复杂度是（）。A．O(1) B．O(n)C．O(n2) D．O(nlog2n)答案：C解释：单链表创建的时间复杂度是O(n)，而要建立一个有序的单链表，则每生成一个新结点时需要和已有的结点进行比较，确定合适的插入位置，所以时间复杂度是O(n2)。(12)以下说法错误的是（）。构时实现的效率低B．顺序存储的线性表可以随机存取C．由于顺序存储要求连续的存储区域，所以在存储管理上不够灵活D．线性表的链式存储结构优于顺序存储结构A．求表长、定位这两种运算在采用顺序存储结构时实现的效率不比采用链式存储结答案：D解释：链式存储结构和顺序存储结构各有优缺点，有不同的适用场合。(13)在单链表中，要将s所指结点插入到p所指结点之后，其语句应为（）。6A．s->next=p+1;p->next=s;B．(*p).next=s;(*s).next=(*p).next;C．s->next=p->next;p->next=s->next;D．s->next=p->next;p->next=s;答案：D(14)在双向链表存储结构中，删除p所指的结点时须修改指针（）。A．p->next->prior=p->prior;p->prior->next=p->next;B．p->next=p->next->next;p->next->prior=p;C．p->prior->next=p;p->prior=p->prior->prior;D．p->prior=p->next->next;p->next=p->prior->prior;答案：A(15)在双向循环链表中，在p指针所指的结点后插入q所指向的新结点，其修改指针的操作是（）。A．p->next=q; q->prior=p;p->next->prior=q;q->next=q;B．p->next=q;p->next->prior=q;q->prior=p;q->next=p->next;C．q->prior=p;q->next=p->next;p->next->prior=q;p->next=q;D．q->prior=p;q->next=p->next;p->next=q;p->next->prior=q;答案：C2．算法设计题（1）将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表的存储空间,不另外占用其它的存储空间。表中不允许有重复的数据。[题目分析]合并后的新表使用头指针Lc指向，pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点，从第一个结点开始进行比较，当两个链表La和Lb均为到达表尾结点时，依次摘取其中较小者重新链接在Lc表的最后。如果两个表中的元素相等，只摘取La表中的元素，删除Lb表中的元素，这样确保合并后表中无重复的元素。当一个表到达表尾结点，为空时，将非空表的剩余元素直接链接在Lc表的最后。[算法描述]void MergeList(LinkList &La,LinkList &Lb,LinkList &Lc){//合并链表La和Lb，合并后的新表使用头指针Lc指向pa=La->next;  pb=Lb->next;//pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点Lc=pc=La;  //用La的头结点作为Lc的头结点while(pa && pb){if(pa->data<pb->data){pc->next=pa;pc=pa;pa=pa->next;}//取较小者La中的元素，将pa链接在pc的后面，pa指针后移else if(pa->data>pb->data) {pc->next=pb; pc=pb; pb=pb->next;}//取较小者Lb中的元素，将pb链接在pc的后面，pb指针后移7else //相等时取La中的元素，删除Lb中的元素{pc->next=pa;pc=pa;pa=pa->next;q=pb->next;delete pb ;pb =q;}}pc->next=pa?pa:pb;    //插入剩余段delete Lb;            //释放Lb的头结点}（2）将两个非递减的有序链表合并为一个非递增的有序链表。要求结果链表仍使用原来两个链表的存储空间,不另外占用其它的存储空间。表中允许有重复的数据。[题目分析]合并后的新表使用头指针Lc指向，pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点，从第一个结点开始进行比较，当两个链表La和Lb均为到达表尾结点时，依次摘取其中较小者重新链接在Lc表的表头结点之后，如果两个表中的元素相等，只摘取La表中的元素，保留Lb表中的元素。当一个表到达表尾结点，为空时，将非空表的剩余元素依次摘取，链接在Lc表的表头结点之后。[算法描述]void MergeList(LinkList& La, LinkList& Lb, LinkList& Lc, ){//合并链表La和Lb，合并后的新表使用头指针Lc指向pa=La->next;  pb=Lb->next;//pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点Lc=pc=La; //用La的头结点作为Lc的头结点Lc->next=NULL;while(pa||pb ){//只要存在一个非空表，用q指向待摘取的元素if(!pa)  {q=pb;  pb=pb->next;}//La表为空，用q指向pb，pb指针后移else if(!pb)  {q=pa;  pa=pa->next;}//Lb表为空，用q指向pa，pa指针后移else if(pa->data<=pb->data)  {q=pa;  pa=pa->next;}//取较小者（包括相等）La中的元素，用q指向pa，pa指针后移else {q=pb;  pb=pb->next;}//取较小者Lb中的元素，用q指向pb，pb指针后移q->next = Lc->next;  Lc->next = q;//将q指向的结点插在Lc表的表头结点之后}delete Lb;             //释放Lb的头结点}8（3）已知两个链表A和B分别表示两个集合，其元素递增排列。请设计算法求出A与B的交集，并存放于A链表中。[题目分析]只有同时出现在两集合中的元素才出现在结果表中,合并后的新表使用头指针Lc指向。pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点，从第一个结点开始进行比较，当两个链表La和Lb均为到达表尾结点时，如果两个表中相等的元素时，摘取La表中的元素，删除Lb表中的元素；如果其中一个表中的元素较小时，删除此表中较小的元素，此表的工作指针后移。当链表La和Lb有一个到达表尾结点，为空时，依次删除另一个非空表中的所有元素。[算法描述]void Mix(LinkList& La, LinkList& Lb, LinkList& Lc){pa=La->next;pb=Lb->next;pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点Lc=pc=La; //用La的头结点作为Lc的头结点while(pa&&pb){ if(pa->data==pb->data)∥交集并入结果表中。{ pc->next=pa;pc=pa;pa=pa->next;u=pb;pb=pb->next; delete u;}else if(pa->data<pb->data) {u=pa;pa=pa->next; delete u;}else {u=pb; pb=pb->next; delete u;}}while(pa){u=pa; pa=pa->next; deleteu;}∥ 释放结点空间while(pb) {u=pb; pb=pb->next; delete u;}∥释放结点空间pc->next=null;∥置链表尾标记。delete Lb;  //释放Lb的头结点}（4）已知两个链表A和B分别表示两个集合，其元素递增排列。请设计算法求出两个集合A和B的差集（即仅由在A中出现而不在B中出现的元素所构成的集合），并以同样的形式存储，同时返回该集合的元素个数。[题目分析]求两个集合A和B的差集是指在A中删除A和B中共有的元素，即删除链表中的相应结点,所以要保存待删除结点的前驱，使用指针pre指向前驱结点。pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点，从第一个结点开始进行比较，当两个链表La和Lb均为到达表尾结点时，如果La表中的元素小于Lb表中的元素，pre置为La表的工作指针pa删除Lb表中的元素；如果其中一个表中的元素较小时，删除此表中较小的元素，此表的工作指针后移。当链表La和Lb有一个为空时，依次删除另一个非空表中的所有元素。[算法描述]9void Difference（LinkList& La, LinkList& Lb,int *n）{∥差集的结果存储于单链表La中，*n是结果集合中元素个数，调用时为0pa=La->next; pb=Lb->next;∥pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点pre=La;∥pre为La中pa所指结点的前驱结点的指针while（pa&&pb）{if（pa->data<q->data）{pre=pa;pa=pa->next;*n++;}∥A链表中当前结点指针后移else if（pa->data>q->data）q=q->next;∥B链表中当前结点指针后移else {pre->next=pa->next;∥处理A，B中元素值相同的结点，应删除u=pa; pa=pa->next;delete u;}∥删除结点}}（5）设计算法将一个带头结点的单链表A分解为两个具有相同结构的链表B、C，其中B表的结点为A表中值小于零的结点，而C表的结点为A表中值大于零的结点（链表A中的元素为非零整数，要求B、C表利用A表的结点）。[题目分析]B表的头结点使用原来A表的头结点，为C表新申请一个头结点。从A表的第一个结点开始，依次取其每个结点p，判断结点p的值是否小于0，利用前插法，将小于0的结点插入B表,大于等于0的结点插入C表。[算法描述]void DisCompose(LinkedList A){  B=A;B->next= NULL;∥B表初始化C=newLNode;∥为C申请结点空间C->next=NULL;∥C初始化为空表p=A->next;∥p为工作指针while(p!= NULL){r=p->next;∥暂存p的后继if(p->data<0){p->next=B->next; B->next=p; }∥将小于0的结点链入B表,前插法else{p->next=C->next;C->next=p;}∥将大于等于0的结点链入C表,前插法p=r;∥p指向新的待处理结点。}}（6）设计一个算法，通过一趟遍历在单链表中确定值最大的结点。[题目分析]10假定第一个结点中数据具有最大值，依次与下一个元素比较，若其小于下一个元素，则设其下一个元素为最大值，反复进行比较，直到遍历完该链表。[算法描述]ElemType Max (LinkList L ){if(L->next==NULL) return NULL;pmax=L->next; //假定第一个结点中数据具有最大值p=L->next->next;while(p != NULL ){//如果下一个结点存在}return pmax->data;if(p->data > pmax->data) pmax=p;//如果p的值大于pmax的值，则重新赋值p=p->next;//遍历链表（7）设计一个算法，通过遍历一趟，将链表中所有结点的链接方向逆转，仍利用原表的存储空间。[题目分析]从首元结点开始，逐个地把链表L的当前结点p插入新的链表头部。[算法描述]void  inverse(LinkList &L){//逆置带头结点的单链表Lp=L->next;  L->next=NULL;while ( p) {q=p->next;    // q指向*p的后继p->next=L->next;L->next=p;       // *p插入在头结点之后p = q;}}（8）设计一个算法，删除递增有序链表中值大于mink且小于maxk的所有元素（mink和maxk是给定的两个参数，其值可以和表中的元素相同，也可以不同）。[题目分析]分别查找第一个值>mink的结点和第一个值≥maxk的结点，再修改指针，删除值大于mink且小于maxk的所有元素。[算法描述]void delete(LinkList &L, int mink, int maxk) {p=L->next; //首元结点while (p && p->data<=mink){ pre=p;  p=p->next; } //查找第一个值>mink的结点if (p)11{while (p && p->data<maxk)  p=p->next;//查找第一个值≥maxk的结点q=pre->next;   pre->next=p;  //修改指针while (q!=p){ s=q->next;  delete q;  q=s; } //释放结点空间}//if}（9）已知p指向双向循环链表中的一个结点，其结点结构为data、prior、next三个域，写出算法change(p),交换p所指向的结点和它的前缀结点的顺序。[题目分析]知道双向循环链表中的一个结点，与前驱交换涉及到四个结点（p结点，前驱结点，前驱的前驱结点，后继结点）六条链。[算法描述]void  Exchange（LinkedList p）∥p是双向循环链表中的一个结点，本算法将p所指结点与其前驱结点交换。{q=p->llink；q->llink->rlink=p；∥p的前驱的前驱之后继为pp->llink=q->llink；∥p的前驱指向其前驱的前驱。q->rlink=p->rlink；∥p的前驱的后继为p的后继。q->llink=p；∥p与其前驱交换p->rlink->llink=q；∥p的后继的前驱指向原p的前驱p->rlink=q；∥p的后继指向其原来的前驱}∥算法exchange结束。（10）已知长度为n的线性表A采用顺序存储结构，请写一时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除线性表中所有值为item的数据元素。[题目分析]在顺序存储的线性表上删除元素，通常要涉及到一系列元素的移动（删第i个元素，第i+1至第n个元素要依次前移）。本题要求删除线性表中所有值为item的数据元素，并未要求元素间的相对位置不变。因此可以考虑设头尾两个指针（i=1，j=n），从两端向中间移动，凡遇到值item的数据元素时，直接将右端元素左移至值为item的数据元素位置。[算法描述]void  Delete（ElemType A[ ]，int  n）∥A是有n个元素的一维数组，本算法删除A中所有值为item的元素。{i=1；j=n；∥设置数组低、高端指针（下标）。while（i<j）{while（i<j && A[i]!=item）i++；∥若值不为item，左移指针。if（i<j）while（i<j && A[j]==item）j--；∥若右端元素为item，指针左移if（i<j）A[i++]=A[j--]；}12第3章栈和队列1．选择题（1）若让元素1，2，3，4，5依次进栈，则出栈次序不可能出现在（）种情况。A．5，4，3，2，1B．2，1，5，4，3C．4，3，1，2，5D．2，3，5，4，1答案：C解释：栈是后进先出的线性表，不难发现C选项中元素1比元素2先出栈，违背了栈的后进先出原则，所以不可能出现C选项所示的情况。（2）若已知一个栈的入栈序列是1，2，3，„，n，其输出序列为p1，p2，p3，„，pn，若p1=n，则pi为（）。A．i               B．n-i C．n-i+1            D．不确定答案：C解释：栈是后进先出的线性表，一个栈的入栈序列是1，2，3，„，n，而输出序列的第一个元素为n，说明1，2，3，„，n一次性全部进栈，再进行输出，所以p1=n，p2=n-1，„，pi=n-i+1。（3）数组Ｑ［ｎ］用来表示一个循环队列，ｆ为当前队列头元素的前一位置，ｒ为队尾元素的位置，假定队列中元素的个数小于ｎ，计算队列中元素个数的公式为（）。A．r-f             B．(n+f-r)%n       C．n+r-fD．（n+r-f)%n答案：D解释：对于非循环队列，尾指针和头指针的差值便是队列的长度，而对于循环队列，差值可能为负数，所以需要将差值加上MAXSIZE（本题为n），然后与MAXSIZE（本题为n）求余，即（n+r-f)%n。（4）链式栈结点为：(data,link)，top指向栈顶.若想摘除栈顶结点，并将删除结点的值保存到x中,则应执行操作（）。A．x=top->data;top=top->link；C．x=top;top=top->link；答案：A解释：x=top->data将结点的值保存到x中，top=top->link栈顶指针指向栈顶下一结点，即摘除栈顶结点。（5）设有一个递归算法如下int fact(int n) {//n大于等于0if(n<=0) return 1;else return n*fact(n-1);}则计算fact(n)需要调用该函数的次数为（）。A．n+1B．n-1C．nD．n+2答案：A13B．top=top->link;x=top->link；D．x=top->link；解释：特殊值法。设n=0，易知仅调用一次fact(n)函数，故选A。（6）栈在（）中有所应用。A．递归调用B．函数调用C．表达式求值D．前三个选项都有答案：D解释：递归调用、函数调用、表达式求值均用到了栈的后进先出性质。（7）为解决计算机主机与打印机间速度不匹配问题，通常设一个打印数据缓冲区。主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是（）。A．队列B．栈C．线性表D．有序表答案：A解释：解决缓冲区问题应利用一种先进先出的线性表，而队列正是一种先进先出的线性表。（8）设栈S和队列Q的初始状态为空，元素e1、e2、e3、e4、e5和e6依次进入栈S，一个元素出栈后即进入Q，若6个元素出队的序列是e2、e4、e3、e6、e5和e1，则栈S的容量至少应该是（）。A．2B．3C．4D．6答案：B解释：元素出队的序列是e2、e4、e3、e6、e5和e1，可知元素入队的序列是e2、e4、e3、e6、e5和e1，即元素出栈的序列也是e2、e4、e3、e6、e5和e1，而元素e1、e2、e3、e4、e5和e6依次进入栈，易知栈S中最多同时存在3个元素，故栈S的容量至少为3。（9）若一个栈以向量V[1..n]存储，初始栈顶指针top设为n+1，则元素x进栈的正确操作是()。A．top++; V[top]=x;C．top--; V[top]=x;答案：C解释：初始栈顶指针top为n+1，说明元素从数组向量的高端地址进栈，又因为元素存储在向量空间V[1..n]中，所以进栈时top指针先下移变为n，之后将元素x存储在V[n]。（10）设计一个判别表达式中左，右括号是否配对出现的算法，采用（）数据结构最佳。A．线性表的顺序存储结构B．队列C.线性表的链式存储结构D.栈答案：D解释：利用栈的后进先出原则。（11）用链接方式存储的队列，在进行删除运算时（）。A.仅修改头指针B.仅修改尾指针C.头、尾指针都要修改D.头、尾指针可能都要修改答案：DB．V[top]=x; top++;D．V[top]=x; top--;14解释：一般情况下只修改头指针，但是，当删除的是队列中最后一个元素时，队尾指针也丢失了，因此需对队尾指针重新赋值。（12）循环队列存储在数组A[0..m]中，则入队时的操作为（）。A. rear=rear+1               B. rear=(rear+1)%(m-1)C. rear=(rear+1)%mD. rear=(rear+1)%(m+1)答案：D解释：数组A[0..m]中共含有m+1个元素，故在求模运算时应除以m+1。（13）最大容量为n的循环队列，队尾指针是rear，队头是front，则队空的条件是（）。A. (rear+1)%n==front                  B. rear==frontC．rear+1==front          D. (rear-l)%n==front答案：B解释：最大容量为n的循环队列，队满条件是(rear+1)%n==front，队空条件是rear==front。（14）栈和队列的共同点是（）。A.都是先进先出B.都是先进后出C.只允许在端点处插入和删除元素D.没有共同点答案：C解释：栈只允许在栈顶处进行插入和删除元素，队列只允许在队尾插入元素和在队头删除元素。（15）一个递归算法必须包括（）。A.递归部分B.终止条件和递归部分C.迭代部分D.终止条件和迭代部分答案：B2．算法设计题（1）将编号为0和1的两个栈存放于一个数组空间V[m]中，栈底分别处于数组的两端。当第0号栈的栈顶指针top[0]等于-1时该栈为空，当第1号栈的栈顶指针top[1]等于m时该栈为空。两个栈均从两端向中间增长。试编写双栈初始化，判断栈空、栈满、进栈和出栈等算法的函数。双栈数据结构的定义如下：Typedef struct{int top[2],bot[2];SElemType *V;int m;}DblStack[题目分析]两栈共享向量空间，将两栈栈底设在向量两端，初始时，左栈顶指针为-1，右栈顶为m。两栈顶指针相邻时为栈满。两栈顶相向、迎面增长，栈顶指针指向栈顶元素。[算法描述]15//栈顶和栈底指针//栈数组//栈最大可容纳元素个数(1)栈初始化int Init(){S.top[0]=-1;S.top[1]=m;return 1; //初始化成功}(2)入栈操作：int push(stk S ,int i,int x)∥i为栈号，i=0表示左栈，i=1为右栈，x是入栈元素。入栈成功返回1，失败返回0{if(i<0||i>1){cout<<“栈号输入不对”<<endl;exit(0);}if(S.top[1]-S.top[0]==1) {cout<<“栈已满”<<endl;return(0);}switch(i){case 0: S.V[++S.top[0]]=x; return(1); break;case 1: S.V[--S.top[1]]=x; return(1);}}∥push(3)退栈操作ElemType pop(stk S,int i)∥退栈。i代表栈号，i=0时为左栈，i=1时为右栈。退栈成功时返回退栈元素∥否则返回-1{if(i<0 || i>1){cout<<“栈号输入错误”<<endl；exit(0);}switch(i){case 0: if(S.top[0]==-1) {cout<<“栈空”<<endl；return（-1）；}else return(S.V[S.top[0]--]);case 1: if(S.top[1]==m {cout<<“栈空”<<endl; return(-1);}else return(S.V[S.top[1]++]);}∥switch}∥算法结束(4)判断栈空int Empty();{return (S.top[0]==-1 && S.top[1]==m);}[算法讨论]请注意算法中两栈入栈和退栈时的栈顶指针的计算。左栈是通常意义下的栈，而右栈入栈操作时，其栈顶指针左移（减1），退栈时，栈顶指针右移（加1）。（2）回文是指正读反读均相同的字符序列，如“abba”和“abdba”均是回文，但“good”不是回文。试写一个算法判定给定的字符向量是否为回文。(提示：将一半字符入栈)16[题目分析]将字符串前一半入栈，然后，栈中元素和字符串后一半进行比较。即将第一个出栈元素和后一半串中第一个字符比较，若相等，则再出栈一个元素与后一个字符比较，„„，直至栈空，结论为字符序列是回文。在出栈元素与串中字符比较不等时，结论字符序列不是回文。[算法描述]#define StackSize 100 //假定预分配的栈空间最多为100个元素typedef char DataType;//假定栈元素的数据类型为字符typedef struct{DataType data[StackSize];int top;}SeqStack;int IsHuiwen( char *t){//判断t字符向量是否为回文，若是，返回1，否则返回0SeqStack s;int i , len;char temp;InitStack( &s);len=strlen(t); //求向量长度for ( i=0; i<len/2; i++)//将一半字符入栈Push( &s, t[i]);while( !EmptyStack( &s)){//每弹出一个字符与相应字符比较temp=Pop (&s);if( temp!=S[i])return 0 ;//不等则返回0else i++;}return 1 ; //比较完毕均相等则返回1}（3）设从键盘输入一整数的序列：a1,a2,a3，…，an，试编写算法实现：用栈结构存储输入的整数，当ai≠-1时，将ai进栈；当ai=-1时，输出栈顶整数并出栈。算法应对异常情况（入栈满等）给出相应的信息。[算法描述]#define maxsize栈空间容量void InOutS(int s[maxsize])//s是元素为整数的栈，本算法进行入栈和退栈操作。{int top=0;             //top为栈顶指针，定义top=0时为栈空。for(i=1; i<=n; i++)    //n个整数序列作处理。17{cin>>x);    //从键盘读入整数序列。if(x!=-1)           //读入的整数不等于-1时入栈。｛if(top==maxsize-1){cout<<“栈满”<<endl;exit(0);}else s[++top]=x; //x入栈。｝else   //读入的整数等于-1时退栈。{if(top==0){cout<<“栈空”<<endl;exit(0);}else cout<<“出栈元素是”<<s[top--]<<endl;}}}//算法结束。（4）从键盘上输入一个后缀表达式，试编写算法计算表达式的值。规定：逆波兰表达式的长度不超过一行，以$符作为输入结束，操作数之间用空格分隔,操作符只可能有+、-、*、/四种运算。例如：234 34+2*$。[题目分析]逆波兰表达式(即后缀表达式)求值规则如下：设立运算数栈OPND,对表达式从左到右扫描(读入)，当表达式中扫描到数时，压入OPND栈。当扫描到运算符时，从OPND退出两个数，进行相应运算，结果再压入OPND栈。这个过程一直进行到读出表达式结束符$，这时OPND栈中只有一个数，就是结果。[算法描述]float expr( )//从键盘输入逆波兰表达式，以‘$’表示输入结束，本算法求逆波兰式表达式的值。｛float OPND[30];   // OPND是操作数栈。init(OPND);       //两栈初始化。float num=0.0;    //数字初始化。cin>>x;//x是字符型变量。while(x!=’$’){switchwhile((x>=’0’&&x<=’9’)||x==’.’)  //拼数if(x!=’.’)   //处理整数{num=num*10+（ord(x)-ord(‘0’)）; cin>>x;}else           //处理小数部分。{scale=10.0; cin>>x;while(x>=’0’&&x<=’9’){num=num+(ord(x)-ord(‘0’)/scale;scale=scale*10;  cin>>x; }}//else18{case‘0’<=x<=’9’:push(OPND,num); num=0.0;//数压入栈，下个数初始化case x=‘’:break;  //遇空格，继续读下一个字符。case x=‘+’:push(OPND,pop(OPND)+pop(OPND));break;case x=‘-’:x1=pop(OPND);x2=pop(OPND);push(OPND,x2-x1);break;case x=‘*’:push(OPND,pop(OPND)*pop(OPND));break;case x=‘/’:x1=pop(OPND);x2=pop(OPND);push(OPND,x2/x1);break;default:       //其它符号不作处理。}//结束switchcin>>x;//读入表达式中下一个字符。}//结束while（x！=‘$’）cout<<“后缀表达式的值为”<<pop(OPND);}//算法结束。[算法讨论]假设输入的后缀表达式是正确的，未作错误检查。算法中拼数部分是核心。若遇到大于等于‘0’且小于等于‘9’的字符，认为是数。这种字符的序号减去字符‘0’的序号得出数。对于整数，每读入一个数字字符，前面得到的部分数要乘上10再加新读入的数得到新的部分数。当读到小数点，认为数的整数部分已完，要接着处理小数部分。小数部分的数要除以10（或10的幂数）变成十分位，百分位，千分位数等等，与前面部分数相加。在拼数过程中，若遇非数字字符，表示数已拼完，将数压入栈中，并且将变量num恢复为0，准备下一个数。这时对新读入的字符进入‘+’、‘-’、‘*’、‘/’及空格的判断，因此在结束处理数字字符的case后，不能加入break语句。（5）假设以I和O分别表示入栈和出栈操作。栈的初态和终态均为空，入栈和出栈的操作序列可表示为仅由I和O组成的序列，称可以操作的序列为合法序列，否则称为非法序列。①下面所示的序列中哪些是合法的？A. IOIIOIOO     B. IOOIOIIO      C. IIIOIOIO     D. IIIOOIOO②通过对①的分析，写出一个算法，判定所给的操作序列是否合法。若合法，返回true，否则返回false（假定被判定的操作序列已存入一维数组中）。答案：①A和D是合法序列，B和C是非法序列。②设被判定的操作序列已存入一维数组A中。int Judge(char A[])//判断字符数组A中的输入输出序列是否是合法序列。如是，返回true，否则返回false。{i=0;                //i为下标。j=k=0;              //j和k分别为I和字母O的的个数。while(A[i]!=‘\0’) //当未到字符数组尾就作。{switch(A[i]){case‘I’: j++; break; //入栈次数增1。19case‘O’: k++; if(k>j){cout<<“序列非法”<<ednl；exit(0);}}i++; //不论A[i]是‘I’或‘O’，指针i均后移。}if(j!=k) {cout<<“序列非法”<<endl；return(false);}else {cout<<“序列合法”<<endl；return(true);}}//算法结束。[算法讨论]在入栈出栈序列（即由‘I’和‘O’组成的字符串）的任一位置，入栈次数（‘I’的个数）都必须大于等于出栈次数（即‘O’的个数），否则视作非法序列，立即给出信息，退出算法。整个序列（即读到字符数组中字符串的结束标记‘\0’），入栈次数必须等于出栈次数（题目中要求栈的初态和终态都为空），否则视为非法序列。(6）假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素站点(注意不设头指针)，试编写相应的置空队、判队空、入队和出队等算法。[题目分析]置空队就是建立一个头节点，并把头尾指针都指向头节点，头节点是不存放数据的；判队空就是当头指针等于尾指针时，队空；入队时，将新的节点插入到链队列的尾部，同时将尾指针指向这个节点；出队时，删除的是队头节点，要注意队列的长度大于1还是等于1的情况，这个时候要注意尾指针的修改，如果等于1，则要删除尾指针指向的节点。[算法描述]//先定义链队结构:typedef struct queuenode{Datatype data;struct queuenode *next;}QueueNode; //以上是结点类型的定义typedef struct{queuenode *rear;}LinkQueue; //只设一个指向队尾元素的指针(1)置空队void InitQueue( LinkQueue *Q){ //置空队：就是使头结点成为队尾元素QueueNode *s;Q->rear = Q->rear->next;//将队尾指针指向头结点while (Q->rear!=Q->rear->next)//当队列非空，将队中元素逐个出队{s=Q->rear->next;Q->rear->next=s->next;delete s;}//回收结点空间20}(2)判队空int EmptyQueue( LinkQueue *Q){ //判队空。当头结点的next指针指向自己时为空队return Q->rear->next->next==Q->rear->next;}(3)入队void EnQueue( LinkQueue *Q, Datatype x){ //入队。也就是在尾结点处插入元素QueueNode *p=new QueueNode;//申请新结点p->data=x; p->next=Q->rear->next;//初始化新结点并链入Q-rear->next=p;Q->rear=p;//将尾指针移至新结点}(4)出队Datatype DeQueue( LinkQueue *Q){//出队,把头结点之后的元素摘下Datatype t;QueueNode *p;if(EmptyQueue( Q ))Error("Queue underflow");p=Q->rear->next->next; //p指向将要摘下的结点x=p->data; //保存结点中数据if (p==Q->rear){//当队列中只有一个结点时，p结点出队后，要将队尾指针指向头结点Q->rear = Q->rear->next;Q->rear->next=p->next;}elseQ->rear->next->next=p->next;//摘下结点pdelete p;//释放被删结点return x;}21（7）假设以数组Q[m]存放循环队列中的元素,同时设置一个标志tag，以tag==0和tag==1来区别在队头指针(front)和队尾指针(rear)相等时，队列状态为“空”还是“满”。试编写与此结构相应的插入(enqueue)和删除(dlqueue)算法。[算法描述](1)初始化SeQueue QueueInit(SeQueue Q){//初始化队列Q.front=Q.rear=0; Q.tag=0;returnQ;}(2)入队SeQueue QueueIn(SeQueue Q,int e){//入队列if((Q.tag==1) && (Q.rear==Q.front)) cout<<"队列已满"<<endl;else{Q.rear=(Q.rear+1) % m;Q.data[Q.rear]=e;if(Q.tag==0) Q.tag=1; //队列已不空}returnQ;}(3)出队ElemType QueueOut(SeQueue Q){//出队列if(Q.tag==0) { cout<<"队列为空"<<endl; exit(0);}else{Q.front=(Q.front+1) % m;e=Q.data[Q.front];if(Q.front==Q.rear) Q.tag=0;//空队列}return(e);}(8）如果允许在循环队列的两端都可以进行插入和删除操作。要求：①写出循环队列的类型定义；②写出“从队尾删除”和“从队头插入”的算法。[题目分析]用一维数组v[0..M-1]实现循环队列，其中M是队列长度。设队头指针front和队尾指针rear，约定front指向队头元素的前一位置，rear指向队尾元素。定义22front=rear时为队空，(rear+1)%m=front为队满。约定队头端入队向下标小的方向发展，队尾端入队向下标大的方向发展。[算法描述]①#define M队列可能达到的最大长度typedef struct{elemtp data[M];int front,rear;}cycqueue;②elemtp delqueue ( cycqueue Q)//Q是如上定义的循环队列，本算法实现从队尾删除，若删除成功，返回被删除元素，否则给出出错信息。{if (Q.front==Q.rear)  {cout<<"队列空"<<endl; exit(0);}Q.rear=(Q.rear-1+M)%M;          //修改队尾指针。return(Q.data[(Q.rear+1+M)%M]); //返回出队元素。}//从队尾删除算法结束void enqueue (cycqueue Q, elemtp x)// Q是顺序存储的循环队列，本算法实现“从队头插入”元素x。{if(Q.rear==(Q.front-1+M)%M)  {cout<<"队满"<<endl; exit(0);)Q.data[Q.front]=x;        //x入队列Q.front=(Q.front-1+M)%M;  //修改队头指针。}//结束从队头插入算法。（9）已知Ackermann函数定义如下:①写出计算Ack(m,n)的递归算法，并根据此算法给出出Ack(2,1)的计算过程。②写出计算Ack(m,n)的非递归算法。[算法描述]int Ack(int m,n){if (m==0) return(n+1);else if(m!=0&&n==0) return(Ack(m-1,1));else return(Ack(m-1,Ack(m,m-1));}//算法结束①Ack(2,1)的计算过程23Ack(2,1)=Ack(1,Ack(2,0))           //因m<>0,n<>0而得②int Ackerman(int m, int n){int akm[M][N];int i,j;for(j=0;j<N;j++) akm[0][j]=j+1;for(i=1;i<m;i++){akm[i][0]=akm[i-1][1];for(j=1;j<N;j++)akm[i][j]=akm[i-1][akm[i][j-1]];}return(akm[m][n]);}//算法结束（10）已知f为单链表的表头指针,链表中存储的都是整型数据，试写出实现下列运算的递归算法：①求链表中的最大整数；②求链表的结点个数；③求所有整数的平均值。[算法描述]①int GetMax(LinkList p){=Ack(1,Ack(1,1))            //因m<>0,n=0而得=Ack(1,Ack(0,Ack(1,0)))     //因m<>0,n<>0而得=Ack(1,Ack(0,Ack(0,1)))    //因m<>0,n=0而得=Ack(1,Ack(0,2))            //因m=0而得=Ack(1,3)                   //因m=0而得=Ack(0,Ack(1,2))            //因m<>0,n<>0而得= Ack(0,Ack(0,Ack(1,1)))    //因m<>0,n<>0而得= Ack(0,Ack(0,Ack(0,Ack(1,0)))) //因m<>0,n<>0而得= Ack(0,Ack(0,Ack(0,Ack(0,1)))) //因m<>0,n=0而得= Ack(0,Ack(0,Ack(0,2)))    //因m=0而得= Ack(0,Ack(0,3))           //因m=0而得= Ack(0,4)                  //因n=0而得=5                          //因n=0而得if(!p->next)else24return p->data;}{}int max=GetMax(p->next);return p->data>=max ? p->data:max;②int GetLength(LinkList p){}if(!p->next)else{}return GetLength(p->next)+1;return 1;③double GetAverage(LinkList p , int n){}if(!p->next)else{}double ave=GetAverage(p->next,n-1);return (ave*(n-1)+p->data)/n;return p->data;25第4章串、数组和广义表1．选择题（1）串是一种特殊的线性表，其特殊性体现在（）。A．可以顺序存储B．数据元素是一个字符C．可以链式存储D．数据元素可以是多个字符若答案：B（2）串下面关于串的的叙述中，（）是不正确的？A．串是字符的有限序列B．空串是由空格构成的串C．模式匹配是串的一种重要运算D．串既可以采用顺序存储，也可以采用链式存储答案：B解释：空格常常是串的字符集合中的一个元素，有一个或多个空格组成的串成为空格串，零个字符的串成为空串，其长度为零。（3）串“ababaaababaa”的next数组为（）。A．012345678999B．012121111212C．011234223456D．0123012322345答案：C（4）串“ababaabab”的nextval为（）。A．010104101B．010102101C．010100011D．010101011答案：A（5）串的长度是指（）。A．串中所含不同字母的个数B．串中所含字符的个数C．串中所含不同字符的个数D．串中所含非空格字符的个数答案：B解释：串中字符的数目称为串的长度。（6）假设以行序为主序存储二维数组A=array[1..100,1..100]，设每个数据元素占2个存储单元，基地址为10，则LOC[5,5]=（）。A．808B．818C．1010D．1020答案：B解释：以行序为主，则LOC[5,5]=[（5-1）*100+（5-1）]*2+10=818。（7）设有数组A[i,j]，数组的每个元素长度为3字节，i的值为1到8，j的值为1到10，数组从内存首地址BA开始顺序存放，当用以列为主存放时，元素A[5,8]的存储首地址为（）。A．BA+141B．BA+180C．BA+222D．BA+225答案：B解释：以列序为主，则LOC[5,8]=[（8-1）*8+（5-1）]*3+BA=BA+180。（8）设有一个10阶的对称矩阵A，采用压缩存储方式，以行序为主存储，a11为第一元素，其存储地址为1，每个元素占一个地址空间，则a85的地址为（）。26A．13B．32C．33D．40答案：C（9）若对n阶对称矩阵A以行序为主序方式将其下三角形的元素(包括主对角线上所有元素)依次存放于一维数组B[1..(n(n+1))/2]中，则在B中确定aij（i<j）的位置k的关系为（）。A．i*(i-1)/2+jB．j*(j-1)/2+iC．i*(i+1)/2+jD．j*(j+1)/2+i答案：B（10）二维数组A的每个元素是由10个字符组成的串，其行下标i=0,1,„,8,列下标j=1,2,„,10。若A按行先存储，元素A[8,5]的起始地址与当A按列先存储时的元素（）的起始地址相同。设每个字符占一个字节。A．A[8,5]B．A[3,10]C. A[5,8]D．A[0,9]答案：B解释：设数组从内存首地址M开始顺序存放，若数组按行先存储，元素A[8,5]的起始地址为：M+[（8-0）*10+（5-1）]*1=M+84；若数组按列先存储，易计算出元素A[3,10]的起始地址为：M+[（10-1）*9+（3-0）]*1=M+84。故选B。（11）设二维数组A[1.. m，1.. n]（即m行n列）按行存储在数组B[1.. m*n]中，则二维数组元素A[i,j]在一维数组B中的下标为（）。A．(i-1)*n+jB．(i-1)*n+j-1C．i*(j-1) D．j*m+i-1答案：A解释：特殊值法。取i=j=1，易知A[1,1]的的下标为1，四个选项中仅有A选项能确定的值为1，故选A。（12）数组A[0..4,-1..-3,5..7]中含有元素的个数（）。A．55B．45C．36D．16答案：B解释：共有5*3*3=45个元素。（13）广义表A=(a,b,(c,d),(e,(f,g)))，则Head(Tail(Head(Tail(Tail(A)))))的值为（）。A．(g)B．(d)C．cD．d答案：D解释：Tail(A)=(b,(c,d),(e,(f,g)))；Tail(Tail(A))=((c,d),(e,(f,g)))；Head(Tail(Tail(A)))=(c,d)；Tail(Head(Tail(Tail(A))))=(d)；Head(Tail(Head(Tail(Tail(A)))))=d。（14）广义表((a,b,c,d))的表头是（），表尾是（）。A．aB．( )C．(a,b,c,d)D．(b,c,d)答案：C、B解释：表头为非空广义表的第一个元素，可以是一个单原子，也可以是一个子表，((a,b,c,d))的表头为一个子表(a,b,c,d)；表尾为除去表头之外，由其余元素构成的表，表为一定是个广义表，((a,b,c,d))的表尾为空表( )。（15）设广义表L=((a,b,c))，则L的长度和深度分别为（）。A．1和1B．1和3C．1和2D．2和3答案：C27解释：广义表的深度是指广义表中展开后所含括号的层数，广义表的长度是指广义表中所含元素的个数。根据定义易知L的长度为1，深度为2。2．应用题（1）已知模式串t=‘abcaabbabcab’写出用KMP法求得的每个字符对应的next和nextval函数值。答案：模式串t的next和nextval值如下：jt串next[j]nextval[j]（2）设目标为t=“abcaabbabcabaacbacba”,模式为p=“abcabaa”①计算模式p的naxtval函数值；②不写出算法,只画出利用KMP算法进行模式匹配时每一趟的匹配过程。答案：①p的nextval函数值为0110132。（p的next函数值为0111232）。②利用KMP(改进的nextval)算法，每趟匹配过程如下：第一趟匹配：abcaabbabcabaacbacbaabcab(i=5,j=5)第二趟匹配：abcaabbabcabaacbacbaabc(i=7,j=3)第三趟匹配：abcaabbabcabaacbacbaa(i=7,j=1)第四趟匹配：abcaabbabcabaac bacba(成功)             abcabaa(i=15,j=8)（3）数组A中，每个元素A[i,j]的长度均为32个二进位,行下标从-1到9，列下标从1到11，从首地址S开始连续存放主存储器中，主存储器字长为16位。求：①存放该数组所需多少单元？②存放数组第4列所有元素至少需多少单元？③数组按行存放时，元素A[7,4]的起始地址是多少？④数组按列存放时，元素A[4,7]的起始地址是多少？答案：每个元素32个二进制位，主存字长16位，故每个元素占2个字长，行下标可平移至1到11。（1）242（2）22（3）s+182（4）s+142281234 5678910 11 12abcaabbabcab011122312345011021301105(4)请将香蕉banana用工具H( )—Head( )，T( )—Tail( )从L中取出。L=(apple,(orange,(strawberry,(banana)),peach),pear)答案：H（H（T（H（T（H（T（L）））））））3．算法设计题（1）写一个算法统计在输入字符串中各个不同字符出现的频度并将结果存入文件（字符串中的合法字符为A-Z这26个字母和0-9这10个数字）。[题目分析]由于字母共26个，加上数字符号10个共36个，所以设一长36的整型数组，前10个分量存放数字字符出现的次数，余下存放字母出现的次数。从字符串中读出数字字符时，字符的ASCII代码值减去数字字符‘0’的ASCII代码值，得出其数值(0..9)，字母的ASCII代码值减去字符‘A’的ASCII代码值加上10，存入其数组的对应下标分量中。遇其它符号不作处理，直至输入字符串结束。[算法描述]void Count（）//统计输入字符串中数字字符和字母字符的个数。｛int i，num[36]；char ch；for（i＝0；i<36；i++）num[i]＝０；//初始化while（（ch＝getchar（））!=‘#’）//‘#’表示输入字符串结束。if（‘0’<=ch<=‘9’）｛i=ch－48;num[i]++；｝//数字字符elseif（‘A’<=ch<=‘Z’）｛i=ch-65+10;num[i]++；｝//字母字符for（i=0；i<10；i++）//输出数字字符的个数（2）写一个递归算法来实现字符串逆序存储，要求不另设串存储空间。[题目分析]实现字符串的逆置并不难，但本题“要求不另设串存储空间”来实现字符串逆序存储，即第一个输入的字符最后存储，最后输入的字符先存储，使用递归可容易做到。[算法描述]voidInvertStore(charA[])//字符串逆序存储的递归算法。{charch;staticinti = 0;//需要使用静态变量cin>>ch;if (ch!= '.')    //规定'.'是字符串输入结束标志29｝cout<<“数字”<<i<<“的个数=”<<num[i]<<endl;cout<<“字母字符”<<i+55<<“的个数=”<<num[i]<<endl;for（i＝10；i<36；i++）//求出字母字符的个数}{InvertStore(A);A[i++] = ch;//字符串逆序存储}A[i] = '\0';  //字符串结尾标记（3）编写算法，实现下面函数的功能。函数void insert(char*s,char*t,int pos)将字符串t插入到字符串s中，插入位置为pos。假设分配给字符串s的空间足够让字符串t插入。（说明：不得使用任何库函数）[题目分析]本题是字符串的插入问题，要求在字符串s的pos位置，插入字符串t。首先应查找字符串s的pos位置，将第pos个字符到字符串s尾的子串向后移动字符串t的长度，然后将字符串t复制到字符串s的第pos位置后。对插入位置pos要验证其合法性，小于1或大于串s的长度均为非法，因题目假设给字符串s的空间足够大，故对插入不必判溢出。[算法描述]void  insert(char *s,char *t,int pos)//将字符串t插入字符串s的第pos个位置。{int i=1,x=0;  char *p=s,*q=t;  //p，q分别为字符串s和t的工作指针if(pos<1) {cout<<“pos参数位置非法”<<endl;exit(0);}while(*p!=’\0’&&i<pos) {p++;i++;} //查pos位置//若pos小于串s长度，则查到pos位置时，i=pos。if(*p == '/0') {cout<<pos<<"位置大于字符串s的长度";exit(0);}else      //查找字符串的尾while(*p!='/0'){p++;i++;}  //查到尾时，i为字符‘\0’的下标，p也指向‘\0’。while(*q!='\0'){q++;x++;}   //查找字符串t的长度x，循环结束时q指向'\0'。for(j=i;j>=pos ;j--){*(p+x)=*p; p--;}//串s的pos后的子串右移，空出串t的位置。q--;  //指针q回退到串t的最后一个字符for(j=1;j<=x;j++) *p--=*q--;  //将t串插入到s的pos位置上[算法讨论]串s的结束标记('\0')也后移了，而串t的结尾标记不应插入到s中。（4）已知字符串S1中存放一段英文，写出算法format(s1,s2,s3,n),将其按给定的长度n格式化成两端对齐的字符串S2,其多余的字符送S3。[题目分析]本题要求字符串s1拆分成字符串s2和字符串s3，要求字符串s2“按给定长度n格式化成两端对齐的字符串”，即长度为n且首尾字符不得为空格字符。算法从左到右扫描字符串s1，找到第一个非空格字符，计数到n，第n个拷入字符串s2的字符不得为空格，然后将余下字符复制到字符串s3中。[算法描述]30void format (char *s1,*s2,*s3)//将字符串s1拆分成字符串s2和字符串s3，要求字符串s2是长n且两端对齐{char *p=s1, *q=s2;int i=0;}（5）设二维数组a[1..m, 1..n]含有m*n个整数。①写一个算法判断a中所有元素是否互不相同?输出相关信息(yes/no)；②试分析算法的时间复杂度。①[题目分析]判断二维数组中元素是否互不相同，只有逐个比较,找到一对相等的元素，就可结论为不是互不相同。如何达到每个元素同其它元素比较一次且只一次？在当前行，每个元素要同本行后面的元素比较一次（下面第一个循环控制变量p的for循环），然后同第i+1行及以后各行元素比较一次，这就是循环控制变量k和p的二层for循环。[算法描述]int JudgEqual(ing a[m][n],int m,n)//判断二维数组中所有元素是否互不相同，如是，返回1；否则，返回0。{for(i=0;i<m;i++)for(j=0;j<n-1;j++){for(p=j+1;p<n;p++) //和同行其它元素比较if(a[i][j]==a[i][p]) {cout<<“no”; return(0); }//只要有一个相同的，就结论不是互不相同31while(*p!= '\0' && *p== ' ') p++;//滤掉s1左端空格if(*p== '\0') {cout<<"字符串s1为空串或空格串"<<endl;exit(0);}while( *p!='\0' && i<n){*q=*p; q++; p++; i++;}//字符串s1向字符串s2中复制if(*p =='\0'){cout<<"字符串s1没有"<<n<<"个有效字符"<<endl; exit(0);}if(*(--q)==' ' ) //若最后一个字符为空格，则需向后找到第一个非空格字符{p-- ;          //p指针也后退while(*p==' '&&*p!='\0') p++;//往后查找一个非空格字符作串s2的尾字符if(*p=='\0'){cout<<"s1串没有"<<n<<"个两端对齐的字符串"<<endl; exit(0);}*q=*p;         //字符串s2最后一个非空字符*(++q)='\0';   //置s2字符串结束标记}*q=s3;p++;      //将s1串其余部分送字符串s3。while (*p!= '\0') {*q=*p; q++; p++;}*q='\0';        //置串s3结束标记for(k=i+1;k<m;k++)  //和第i+1行及以后元素比较for(p=0;p<n;p++)if(a[i][j]==a[k][p]) {cout<<“no”; return(0); }}// for(j=0;j<n-1;j++)cout<<“yes”; return(1);   //元素互不相同}//算法JudgEqual结束②二维数组中的每一个元素同其它元素都比较一次，数组中共m*n个元素，第1个元素同其它m*n-1个元素比较，第2个元素同其它m*n-2个元素比较，„„，第m*n-1个元素同最后一个元素(m*n)比较一次,所以在元素互不相等时总的比较次数为(m*n-1)+(m*n-2)+„+2+1=（m*n）(m*n-1)/2。在有相同元素时,可能第一次比较就相同,也可能最后一次比较时相同,设在(m*n-1)个位置上均可能相同,这时的平均比较次数约为（m*n）(m*n-1)/4，总的时间复杂度是O(n)。(6)设任意n个整数存放于数组A(1:n)中，试编写算法，将所有正数排在所有负数前面（要求算法复杂度为0(n)）。[题目分析]本题属于排序问题，只是排出正负，不排出大小。可在数组首尾设两个指针i和j，i自小至大搜索到负数停止，j自大至小搜索到正数停止。然后i和j所指数据交换，继续以上过程，直到i=j为止。[算法描述]void Arrange(int A[],int n)//n个整数存于数组A中，本算法将数组中所有正数排在所有负数的前面{int i=0,j=n-1,x;  //用类C编写，数组下标从0开始while(i<j){while(i<j && A[i]>0)  i++;while(i<j && A[j]<0)  j--;if(i<j) {x=A[i]; A[i++]=A[j]; A[j--]=x; }//交换A[i]与A[j]}// while(i<j)}//算法Arrange结束.[算法讨论]对数组中元素各比较一次，比较次数为n。最佳情况(已排好,正数在前,负数在后)不发生交换，最差情况(负数均在正数前面)发生n/2次交换。用类c编写，数组界偶是0..n-1。空间复杂度为O(1).324第5章树和二叉树1．选择题（1）把一棵树转换为二叉树后，这棵二叉树的形态是（）。A．唯一的Ｂ．有多种C．有多种，但根结点都没有左孩子Ｄ．有多种，但根结点都没有右孩子答案：A解释：因为二叉树有左孩子、右孩子之分，故一棵树转换为二叉树后，这棵二叉树的形态是唯一的。（2）由3个结点可以构造出多少种不同的二叉树？（）A．2       B．3         C．4      D．5答案：D解释：五种情况如下：AABCABCABCABCBC（3）一棵完全二叉树上有1001个结点，其中叶子结点的个数是（）。A．250   B．500    C．254     D．501答案：D解释：设度为0结点（叶子结点）个数为A，度为1的结点个数为B，度为2的结点个数为C，有A=C+1，A+B+C=1001，可得2C+B=1000，由完全二叉树的性质可得B=0或1，又因为C为整数，所以B=0，C=500，A=501，即有501个叶子结点。（4）一个具有1025个结点的二叉树的高h为（）。A．11        B．10     C．11至1025之间D．10至1024之间答案：C解释：若每层仅有一个结点，则树高h为1025；且其最小树高为log21025+ 1=11，即h在11至1025之间。（5）深度为h的满m叉树的第k层有（）个结点。(1=<k=<h)A．mk-1B．m-1          C．mD．m-1hk-1kh-1h答案：A解释：深度为h的满m叉树共有m-1个结点，第k层有m（6）利用二叉链表存储树，则根结点的右指针是（）。A．指向最左孩子B．指向最右孩子C．空D．非空答案：C个结点。33解释：利用二叉链表存储树时，右指针指向兄弟结点，因为根节点没有兄弟结点，故根节点的右指针指向空。（7）对二叉树的结点从1开始进行连续编号，要求每个结点的编号大于其左、右孩子的编号，同一结点的左右孩子中，其左孩子的编号小于其右孩子的编号，可采用（）遍历实现编号。A．先序B.中序C.后序D.从根开始按层次遍历答案：C解释：根据题意可知按照先左孩子、再右孩子、最后双亲结点的顺序遍历二叉树，即后序遍历二叉树。（8）若二叉树采用二叉链表存储结构，要交换其所有分支结点左、右子树的位置，利用（）遍历方法最合适。A．前序B．中序C．后序D．按层次答案：C解释：后续遍历和层次遍历均可实现左右子树的交换，不过层次遍历的实现消耗比后续大，后序遍历方法最合适。（9）在下列存储形式中，（）不是树的存储形式？A．双亲表示法B．孩子链表表示法C．孩子兄弟表示法D．顺序存储表示法答案：D解释：树的存储结构有三种：双亲表示法、孩子表示法、孩子兄弟表示法，其中孩子兄弟表示法是常用的表示法，任意一棵树都能通过孩子兄弟表示法转换为二叉树进行存储。（10）一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足（）。A．所有的结点均无左孩子B．所有的结点均无右孩子C．只有一个叶子结点D．是任意一棵二叉树答案：C解释：因为先序遍历结果是“中左右”，后序遍历结果是“左右中”，当没有左子树时，就是“中右”和“右中”；当没有右子树时，就是“中左”和“左中”。则所有的结点均无左孩子或所有的结点均无右孩子均可，所以A、B不能选，又所有的结点均无左孩子与所有的结点均无右孩子时，均只有一个叶子结点，故选C。（11）设哈夫曼树中有199个结点，则该哈夫曼树中有（）个叶子结点。A．99C．101答案：B解释：在哈夫曼树中没有度为1的结点，只有度为0（叶子结点）和度为2的结点。设叶子结点的个数为n0，度为2的结点的个数为n2，由二叉树的性质n0=n2+1，则总结点数n=n0+n2=2*n0-1，得到n0=100。（12）若X是二叉中序线索树中一个有左孩子的结点，且X不为根，则X的前驱为（）。A．X的双亲B．X的右子树中最左的结点34B．100D．102C．X的左子树中最右结点D．X的左子树中最右叶结点答案：C（13）引入二叉线索树的目的是（）。A．加快查找结点的前驱或后继的速度B．为了能在二叉树中方便的进行插入与删除C．为了能方便的找到双亲D．使二叉树的遍历结果唯一答案：A（14）设F是一个森林，B是由F变换得的二叉树。若F中有n个非终端结点，则B中右指针域为空的结点有（）个。A．n−1答案：C（15）n（n≥2）个权值均不相同的字符构成哈夫曼树，关于该树的叙述中，错误的是（）。A．该树一定是一棵完全二叉树B．树中一定没有度为1的结点C．树中两个权值最小的结点一定是兄弟结点D．树中任一非叶结点的权值一定不小于下一层任一结点的权值答案：A解释：哈夫曼树的构造过程是每次都选取权值最小的树作为左右子树构造一棵新的二叉树，所以树中一定没有度为1的结点、两个权值最小的结点一定是兄弟结点、任一非叶结点的权值一定不小于下一层任一结点的权值。2．应用题（1）试找出满足下列条件的二叉树①先序序列与后序序列相同②中序序列与后序序列相同③先序序列与中序序列相同④中序序列与层次遍历序列相同答案：先序遍历二叉树的顺序是“根—左子树—右子树”，中序遍历“左子树—根—右子树”，后序遍历顺序是：“左子树—右子树―根＂，根据以上原则有①或为空树，或为只有根结点的二叉树②或为空树，或为任一结点至多只有左子树的二叉树．③或为空树，或为任一结点至多只有右子树的二叉树．④或为空树，或为任一结点至多只有右子树的二叉树（2）设一棵二叉树的先序序列：A B D F C E G H，中序序列：B F D A G E H C①画出这棵二叉树。②画出这棵二叉树的后序线索树。③将这棵二叉树转换成对应的树（或森林）。答案：35B．nC．n + 1D．n + 2AABCBADECHBDF①②CEnullFDEFGGHGH③（3）假设用于通信的电文仅由8个字母组成，字母在电文中出现的频率分别为0.07，0.19，0.02，0.06，0.32，0.03，0.21，0.10。①试为这8个字母设计赫夫曼编码。②试设计另一种由二进制表示的等长编码方案。③对于上述实例，比较两种方案的优缺点。答案：方案1；哈夫曼编码先将概率放大100倍，以方便构造哈夫曼树。w={7,19,2,6,32,3,21,10}，按哈夫曼规则：【[（2,3），6], (7,10)】,„„19,21,32（100）（40）（60）192132（28）（17）（11）7106（5）230101011921320101 01710 6012336方案比较：字母编号123456方案1的WPL＝2(0.19+0.32+0.21)+4(0.07+0.06+0.10)+5(0.02+0.03)=1.44+0.92+0.25=2.61方案2的WPL＝3(0.19+0.32+0.21+0.07+0.06+0.10+0.02+0.03)=3结论：哈夫曼编码优于等长二进制编码（4）已知下列字符A、B、C、D、E、F、G的权值分别为3、12、7、4、2、8，11，试填写出其对应哈夫曼树HT的存储结构的初态和终态。答案：初态:1234567891011121337对应编码1100001111011101011111011101出现频率0.070.190.020.060.320.030.210.10字母编号12345678对应编码000001010011100101110111出现频率0.070.190.020.060.320.030.210.1078weight312742811parent0000000000000lchild0000000000000rchild0000000000000终态：123456789101112133．算法设计题以二叉链表作为二叉树的存储结构，编写以下算法：（1）统计二叉树的叶结点个数。[题目分析]如果二叉树为空，返回0，如果二叉树不为空且左右子树为空，返回1，如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数。[算法描述]int LeafNodeCount(BiTree T){}（2）判别两棵树是否相等。[题目分析]先判断当前节点是否相等(需要处理为空、是否都为空、是否相等)，如果当前节点不相等，直接返回两棵树不相等;如果当前节点相等，那么就递归的判断他们的左右孩子是否相等。38weight3127428115915202747parent812109810119111213130lchild00000005439211rchild000000018671012if(T==NULL)return 0; //如果是空树，则叶子结点个数为0return 1; //判断结点是否是叶子结点（左孩子右孩子都为空），若是则返回1return LeafNodeCount(T->lchild)+LeafNodeCount(T->rchild);else if(T->lchild==NULL&&T->rchild==NULL)else[算法描述]int compareTree(TreeNode* tree1, TreeNode* tree2)//用分治的方法做，比较当前根，然后比较左子树和右子树{bool tree1IsNull = (tree1==NULL);bool tree2IsNull = (tree2==NULL);if(tree1IsNull != tree2IsNull){return 1;}if(tree1IsNull && tree2IsNull){//如果两个都是NULL，则相等return 0;}//如果根节点不相等，直接返回不相等，否则的话，看看他们孩子相等不相等if(tree1->c != tree2->c){return 1;}return (compareTree(tree1->left,tree2->left)&compareTree(tree1->right,tree2->right))(compareTree(tree1->left,tree2->right)&compareTree(tree1->right,tree2->left));}//算法结束（3）交换二叉树每个结点的左孩子和右孩子。[题目分析]如果某结点左右子树为空，返回，否则交换该结点左右孩子，然后递归交换左右子树。[算法描述]void ChangeLR(BiTree &T){BiTree temp;if(T->lchild==NULL&&T->rchild==NULL)else{temp = T->lchild;T->lchild = T->rchild;T->rchild = temp;return;}//交换左右孩子ChangeLR(T->lchild);//递归交换左子树ChangeLR(T->rchild);//递归交换右子树39}（4）设计二叉树的双序遍历算法（双序遍历是指对于二叉树的每一个结点来说，先访问这个结点，再按双序遍历它的左子树，然后再一次访问这个结点，接下来按双序遍历它的右子树）。[题目分析]若树为空，返回；若某结点为叶子结点，则仅输出该结点；否则先输出该结点，递归遍历其左子树，再输出该结点，递归遍历其右子树。[算法描述]void DoubleTraverse(BiTree T){}（5）计算二叉树最大的宽度（二叉树的最大宽度是指二叉树所有层中结点个数的最大值）。[题目分析]求二叉树高度的算法见上题。求最大宽度可采用层次遍历的方法，记下各层结点数，每层遍历完毕，若结点数大于原先最大宽度，则修改最大宽度。[算法描述]int Width(BiTree bt)//求二叉树bt的最大宽度{if (bt==null) return (0);  //空二叉树宽度为0else{BiTree Q[];//Q是队列，元素为二叉树结点指针，容量足够大front=1;rear=1;last=1;//front队头指针,rear队尾指针,last同层最右结点在队列中的位置temp=0; maxw=0;       //temp记局部宽度, maxw记最大宽度Q[rear]=bt;           //根结点入队列while(front<=last){p=Q[front++]; temp++; //同层元素数加1if (p->lchild!=null)  Q[++rear]=p->lchild;   //左子女入队if (p->rchild!=null)  Q[++rear]=p->rchild;   //右子女入队if (front>last)      //一层结束，40if(T == NULL){}cout<<T->data;DoubleTraverse(T->lchild);   //递归遍历左子树cout<<T->data;DoubleTraverse(T->rchild);   //递归遍历右子树return;cout<<T->data;     //叶子结点输出else if(T->lchild==NULL&&T->rchild==NULL)else{last=rear;if(temp>maxw) maxw=temp;//last指向下层最右元素,更新当前最大宽度temp=0;}//if}//whilereturn (maxw);}//结束width（6）用按层次顺序遍历二叉树的方法，统计树中具有度为1的结点数目。[题目分析]若某个结点左子树空右子树非空或者右子树空左子树非空，则该结点为度为1的结点[算法描述]int Level(BiTree bt) //层次遍历二叉树，并统计度为1的结点的个数{int num=0; //num统计度为1的结点的个数if(bt){QueueInit(Q); QueueIn(Q,bt);//Q是以二叉树结点指针为元素的队列while(!QueueEmpty(Q)){p=QueueOut(Q); cout<<p->data;     //出队,访问结点if(p->lchild && !p->rchild ||!p->lchild && p->rchild)num++;//度为1的结点if(p->lchild) QueueIn(Q,p->lchild); //非空左子女入队if(p->rchild) QueueIn(Q,p->rchild); //非空右子女入队} //while(!QueueEmpty(Q))}//if(bt)return(num);}//返回度为1的结点的个数（7）求任意二叉树中第一条最长的路径长度，并输出此路径上各结点的值。[题目分析]因为后序遍历栈中保留当前结点的祖先的信息，用一变量保存栈的最高栈顶指针，每当退栈时，栈顶指针高于保存最高栈顶指针的值时，则将该栈倒入辅助栈中，辅助栈始终保存最长路径长度上的结点，直至后序遍历完毕，则辅助栈中内容即为所求。[算法描述]void LongestPath(BiTree bt)//求二叉树中的第一条最长路径长度{BiTree p=bt,l[],s[];//l, s是栈，元素是二叉树结点指针，l中保留当前最长路径中的结点int i，top=0,tag[],longest=0;while(p || top>0){while(p) {s[++top]=p；tag[top]=0; p=p->Lc;} //沿左分枝向下41if(tag[top]==1)    //当前结点的右分枝已遍历{if(!s[top]->Lc && !s[top]->Rc)  //只有到叶子结点时，才查看路径长度if(top>longest){for(i=1;i<=top;i++) l[i]=s[i]; longest=top; top--;}//保留当前最长路径到l栈，记住最高栈顶指针，退栈}else if(top>0) {tag[top]=1; p=s[top].Rc;}   //沿右子分枝向下}//while(p!=null||top>0)}//结束LongestPath（8）输出二叉树中从每个叶子结点到根结点的路径。[题目分析]采用先序遍历的递归方法，当找到叶子结点*b时，由于*b叶子结点尚未添加到path中，因此在输出路径时还需输出b->data值。[算法描述]void AllPath(BTNode *b,ElemType path[],int pathlen){int i;if (b!=NULL){if (b->lchild==NULL && b->rchild==NULL) //*b为叶子结点{cout << " " << b->data << "到根结点路径:" << b->data;for (i=pathlen-1;i>=0;i--)cout << endl;}else{path[pathlen]=b->data;//将当前结点放入路径中pathlen++;//路径长度增1AllPath(b->lchild,path,pathlen); //递归扫描左子树AllPath(b->rchild,path,pathlen); //递归扫描右子树pathlen--;//恢复环境}}//if (b!=NULL)}//算法结束第6章图421．选择题（1）在一个图中，所有顶点的度数之和等于图的边数的（）倍。A．1/2B．1C．2D．4答案：C（2）在一个有向图中，所有顶点的入度之和等于所有顶点的出度之和的（）倍。A．1/2B．1C．2D．4答案：B解释：有向图所有顶点入度之和等于所有顶点出度之和。（3）具有n个顶点的有向图最多有（）条边。A．n B．n(n-1)C．n(n+1) D．n2答案：B解释：有向图的边有方向之分，即为从n个顶点中选取2个顶点有序排列，结果为n(n-1)。（4）n个顶点的连通图用邻接距阵表示时，该距阵至少有（）个非零元素。A．n B．2(n-1)C．n/2D．n2答案：B（5）G是一个非连通无向图，共有28条边，则该图至少有（）个顶点。A．7 B．8C．9 D．10答案：C解释：8个顶点的无向图最多有8*7/2=28条边，再添加一个点即构成非连通无向图，故至少有9个顶点。（6）若从无向图的任意一个顶点出发进行一次深度优先搜索可以访问图中所有的顶点，则该图一定是（）图。A．非连通B．连通C．强连通D．有向答案：B解释：即从该无向图任意一个顶点出发有到各个顶点的路径，所以该无向图是连通图。（7）下面（）算法适合构造一个稠密图G的最小生成树。A．Prim算法B．Kruskal算法C．Floyd算法D．Dijkstra算法答案：A解释：Prim算法适合构造一个稠密图G的最小生成树，Kruskal算法适合构造一个稀疏图G的最小生成树。（8）用邻接表表示图进行广度优先遍历时，通常借助（）来实现算法。A．栈B.队列C.树D．图答案：B解释：广度优先遍历通常借助队列来实现算法，深度优先遍历通常借助栈来实现算法。（9）用邻接表表示图进行深度优先遍历时，通常借助（）来实现算法。A．栈B.队列C.树D．图答案：A43解释：广度优先遍历通常借助队列来实现算法，深度优先遍历通常借助栈来实现算法。（10）深度优先遍历类似于二叉树的（）。A．先序遍历B．中序遍历C．后序遍历D．层次遍历答案：A（11）广度优先遍历类似于二叉树的（）。A．先序遍历B．中序遍历C．后序遍历D．层次遍历答案：D（12）图的BFS生成树的树高比DFS生成树的树高（）。A．小B．相等C．小或相等D．大或相等答案：C解释：对于一些特殊的图，比如只有一个顶点的图，其BFS生成树的树高和DFS生成树的树高相等。一般的图，根据图的BFS生成树和DFS树的算法思想，BFS生成树的树高比DFS生成树的树高小。（13）已知图的邻接矩阵如图6.30所示，则从顶点v0出发按深度优先遍历的结果是（）。图6.30邻接矩阵（14）已知图的邻接表如图6.31所示，则从顶点v0出发按广度优先遍历的结果是（），按深度优先遍历的结果是（）。图6.31邻接表A．0 1 3 2答案：D、DB．0 2 3 1C．0 3 2 1D．0 1 2 3（15）下面（）方法可以判断出一个有向图是否有环。A．深度优先遍历B．拓扑排序C．求最短路径D．求关键路径答案：B2．应用题44（1）已知图6.32所示的有向图，请给出：①每个顶点的入度和出度；②邻接矩阵；③邻接表；④逆邻接表。图6.32有向图图6.33无向网答案：（2）已知如图6.33所示的无向网，请给出：①邻接矩阵；②邻接表；③最小生成树答案：45①③4345593555557654973632526546②abcdefg→→→→→→→baabbdd4435965→→→→→→→ccbcdef3555732→→→→→→ddefgh5→e95→h57→f6→g5→h4326（3）已知图的邻接矩阵如图6.34所示。试分别画出自顶点1出发进行遍历所得的深度优先生成树和广度优先生成树。（4）有向网如图6.35所示，试用迪杰斯特拉算法求出从顶点a到其他各顶点间的最短路径，完成表6.9。图6.28邻接矩阵46图6.34邻接矩阵图6.35有向网表6.9D终点bcdefgi=115(a,b)2(a,c)12(a,d)∞∞∞S终点集{a,c}{a,c,f}{a,c,f,e}i=215(a,b)12(a,d)10(a,c,e)6(a,c,f)∞i=315(a,b)11(a,c,f,d)10(a,c,e)16(a,c,f,g)i=415(a,b)11(a,c,f,d)16(a,c,f,g){a,c,f,e,d}i=515(a,b)14(a,c,f,d,g){a,c,f,e,d,g}{a,c,f,e,d,g,b}i=615(a,b)（5）试对图6.36所示的AOE-网：①求这个工程最早可能在什么时间结束；②求每个活动的最早开始时间和最迟开始时间；③确定哪些活动是关键活动47图6.36AOE-网答案：按拓扑有序的顺序计算各个顶点的最早可能开始时间Ve和最迟允许开始时间Vl。然后再计算各个活动的最早可能开始时间e和最迟允许开始时间l，根据l-e= 0?来确定关键活动，从而确定关键路径。1VeVl00<1, 2>el3．算法设计题（1）分别以邻接矩阵和邻接表作为存储结构，实现以下图的基本操作：①增加一个新顶点v，InsertVex(G, v)；②删除顶点v及其相关的边，DeleteVex(G,v);③增加一条边<v，w>，InsertArc(G,v,w);④删除一条边<v，w>，DeleteArc(G,v,w)。[算法描述]假设图G为有向无权图，以邻接矩阵作为存储结构四个算法分别如下：①增加一个新顶点vStatus Insert_Vex(MGraph &G, char v)//在邻接矩阵表示的图G上插入顶点v{if(G.vexnum+1)>MAX_VERTEX_NUM return INFEASIBLE;G.vexs[++G.vexnum]=v;return OK;}//Insert_Vex②删除顶点v及其相关的边，Status Delete_Vex(MGraph &G,char v)//在邻接矩阵表示的图G上删除顶点v{n=G.vexnum;if((m=LocateVex(G,v))<0) return ERROR;4821919<1, 3>00031515<3, 2>1515042937<2, 4>1927853838<2, 5>19190<3, 5>15271264343<4, 6>29378<5, 6>38380017-e17此工程最早完成时间为43。关键路径为<1, 3><3, 2><2, 5><5, 6>数据结构（C语言版）（第2版）课后习题答案李冬梅2015.3目录第第第第第第第第1章绪论......................................................................................................................12章线性表..................................................................................................................53章栈和队列............................................................................................................134章串、数组和广义表.............................................................................................265章树和二叉树.........................................................................................................336章图........................................................................................................................427章查找....................................................................................................................548章排序....................................................................................................................65II第1章绪论1．简述下列概念：数据、数据元素、数据项、数据对象、数据结构、逻辑结构、存储结构、抽象数据类型。答案：数据：是客观事物的符号表示，指所有能输入到计算机中并被计算机程序处理的符号的总称。如数学计算中用到的整数和实数，文本编辑所用到的字符串，多媒体程序处理的图形、图像、声音、动画等通过特殊编码定义后的数据。数据元素：是数据的基本单位，在计算机中通常作为一个整体进行考虑和处理。在有些情况下，数据元素也称为元素、结点、记录等。数据元素用于完整地描述一个对象，如一个学生记录，树中棋盘的一个格局（状态）、图中的一个顶点等。数据项：是组成数据元素的、有独立含义的、不可分割的最小单位。例如，学生基本信息表中的学号、姓名、性别等都是数据项。数据对象：是性质相同的数据元素的集合，是数据的一个子集。例如：整数数据对象是集合N={0，±1，±2，„}，字母字符数据对象是集合C={‘A’，‘B’，„，‘Z’，‘a’，‘b’，„，‘z’}，学生基本信息表也可是一个数据对象。数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。换句话说，数据结构是带“结构”的数据元素的集合，“结构”就是指数据元素之间存在的关系。逻辑结构：从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此，数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。存储结构：数据对象在计算机中的存储表示，也称为物理结构。抽象数据类型：由用户定义的，表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称。具体包括三部分：数据对象、数据对象上关系的集合和对数据对象的基本操作的集合。2．试举一个数据结构的例子，叙述其逻辑结构和存储结构两方面的含义和相互关系。答案：例如有一张学生基本信息表，包括学生的学号、姓名、性别、籍贯、专业等。每个学生基本信息记录对应一个数据元素，学生记录按顺序号排列，形成了学生基本信息记录的线性序列。对于整个表来说，只有一个开始结点(它的前面无记录)和一个终端结点(它的后面无记录)，其他的结点则各有一个也只有一个直接前趋和直接后继。学生记录之间的这种关系就确定了学生表的逻辑结构，即线性结构。这些学生记录在计算机中的存储表示就是存储结构。如果用连续的存储单元(如用数组表示)来存放这些记录，则称为顺序存储结构；如果存储单元不连续，而是随机存放各个记录，然后用指针进行链接，则称为链式存储结构。即相同的逻辑结构，可以对应不同的存储结构。3．简述逻辑结构的四种基本关系并画出它们的关系图。1答案：（1）集合结构数据元素之间除了“属于同一集合”的关系外，别无其他关系。例如，确定一名学生是否为班级成员，只需将班级看做一个集合结构。（2）线性结构数据元素之间存在一对一的关系。例如，将学生信息数据按照其入学报到的时间先后顺序进行排列，将组成一个线性结构。（3）树结构数据元素之间存在一对多的关系。例如，在班级的管理体系中，班长管理多个组长，每位组长管理多名组员，从而构成树形结构。（4）图结构或网状结构数据元素之间存在多对多的关系。例如，多位同学之间的朋友关系，任何两位同学都可以是朋友，从而构成图形结构或网状结构。其中树结构和图结构都属于非线性结构。四类基本逻辑结构关系图4．存储结构由哪两种基本的存储方法实现？答案：（1）顺序存储结构顺序存储结构是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系，通常借助程序设计语言的数组类型来描述。（2）链式存储结构顺序存储结构要求所有的元素依次存放在一片连续的存储空间中，而链式存储结构，无需占用一整块存储空间。但为了表示结点之间的关系，需要给每个结点附加指针字段，用于存放后继元素的存储地址。所以链式存储结构通常借助于程序设计语言的指针类型来描述。5．选择题（1）在数据结构中，从逻辑上可以把数据结构分成（）。A．动态结构和静态结构B．紧凑结构和非紧凑结构2C．线性结构和非线性结构D．内部结构和外部结构答案：C（2）与数据元素本身的形式、内容、相对位置、个数无关的是数据的（）。A．存储结构B．存储实现C．逻辑结构D．运算实现答案：C（3）通常要求同一逻辑结构中的所有数据元素具有相同的特性，这意味着（）。A．数据具有同一特点B．不仅数据元素所包含的数据项的个数要相同，而且对应数据项的类型要一致C．每个数据元素都一样D．数据元素所包含的数据项的个数要相等答案：B（4）以下说法正确的是（）。A．数据元素是数据的最小单位B．数据项是数据的基本单位C．数据结构是带有结构的各数据项的集合D．一些表面上很不相同的数据可以有相同的逻辑结构答案：D解释：数据元素是数据的基本单位，数据项是数据的最小单位，数据结构是带有结构的各数据元素的集合。（5）算法的时间复杂度取决于（）。A．问题的规模答案：D解释：算法的时间复杂度不仅与问题的规模有关，还与问题的其他因素有关。如某些排序的算法，其执行时间与待排序记录的初始状态有关。为此，有时会对算法有最好、最坏以及平均时间复杂度的评价。（6）以下数据结构中，（）是非线性数据结构A．树B．字符串C．队列D．栈答案：A6．试分析下面各程序段的时间复杂度。（1）x=90; y=100;while(y>0)if(x>100){x=x-10;y--;}else x++;答案：O(1)解释：程序的执行次数为常数阶。3B．待处理数据的初态D．A和BC．计算机的配置（2）for (i=0; i<n; i++)for (j=0; j<m; j++)a[i][j]=0;答案：O(m*n)解释：语句a[i][j]=0;的执行次数为m*n。（3）s=0;for i=0; i<n; i++)for(j=0; j<n; j++)s+=B[i][j];sum=s;2答案：O(n)解释：语句s+=B[i][j];的执行次数为n。（4）i=1;while(i<=n)i=i*3;答案：O(log3n)解释：语句i=i*3;的执行次数为log3n。（5）x=0;for(i=1; i<n; i++)for (j=1; j<=n-i; j++)x++;2答案：O(n)解释：语句x++;的执行次数为n-1+n-2+„„＋1= n(n-1)/2。（6）x=n; //n>1y=0;while(x≥(y+1)* (y+1))y++;答案：O(n)解释：语句y++;的执行次数为n。24第2章线性表1．选择题（1）顺序表中第一个元素的存储地址是100，每个元素的长度为2，则第5个元素的地址是（）。A．110B．108C．100D．120答案：B解释：顺序表中的数据连续存储，所以第5个元素的地址为：100+2*4=108。（2）在n个结点的顺序表中，算法的时间复杂度是O(1)的操作是（）。A．访问第i个结点（1≤i≤n）和求第i个结点的直接前驱（2≤i≤n）B．在第i个结点后插入一个新结点（1≤i≤n）C．删除第i个结点（1≤i≤n）D．将n个结点从小到大排序答案：A解释：在顺序表中插入一个结点的时间复杂度都是O(n2)，排序的时间复杂度为O(n2)或O(nlog2n)。顺序表是一种随机存取结构，访问第i个结点和求第i个结点的直接前驱都可以直接通过数组的下标直接定位，时间复杂度是O(1)。（3）向一个有127个元素的顺序表中插入一个新元素并保持原来顺序不变，平均要移动的元素个数为（）。A．8 B．63.5 C．63D．7答案：B解释：平均要移动的元素个数为：n/2。（4）链接存储的存储结构所占存储空间（）。A．分两部分，一部分存放结点值，另一部分存放表示结点间关系的指针B．只有一部分，存放结点值C．只有一部分，存储表示结点间关系的指针D．分两部分，一部分存放结点值，另一部分存放结点所占单元数答案：A（5）线性表若采用链式存储结构时，要求内存中可用存储单元的地址（）。A．必须是连续的B．部分地址必须是连续的C．一定是不连续的D．连续或不连续都可以答案：D（6）线性表Ｌ在（）情况下适用于使用链式结构实现。A．需经常修改Ｌ中的结点值Ｂ．需不断对Ｌ进行删除插入C．Ｌ中含有大量的结点Ｄ．Ｌ中结点结构复杂答案：B5解释：链表最大的优点在于插入和删除时不需要移动数据，直接修改指针即可。（7）单链表的存储密度（）。A．大于1B．等于1C．小于1D．不能确定答案：C解释：存储密度是指一个结点数据本身所占的存储空间和整个结点所占的存储空间之比，假设单链表一个结点本身所占的空间为D，指针域所占的空间为N，则存储密度为：D/(D+N)，一定小于1。（8）将两个各有n个元素的有序表归并成一个有序表，其最少的比较次数是（）。A．nB．2n-1 C．2n D．n-1答案：A解释：当第一个有序表中所有的元素都小于（或大于）第二个表中的元素，只需要用第二个表中的第一个元素依次与第一个表的元素比较，总计比较n次。（9）在一个长度为n的顺序表中，在第i个元素（1≤i≤n+1）之前插入一个新元素时须向后移动（）个元素。A．n-iB．n-i+1C．n-i-1 D．I答案：B(10)线性表L=(a1，a2,„„an)，下列说法正确的是（）。A．每个元素都有一个直接前驱和一个直接后继B．线性表中至少有一个元素C．表中诸元素的排列必须是由小到大或由大到小D．除第一个和最后一个元素外，其余每个元素都有一个且仅有一个直接前驱和直接后继。答案：D(11)创建一个包括n个结点的有序单链表的时间复杂度是（）。A．O(1) B．O(n)C．O(n2) D．O(nlog2n)答案：C解释：单链表创建的时间复杂度是O(n)，而要建立一个有序的单链表，则每生成一个新结点时需要和已有的结点进行比较，确定合适的插入位置，所以时间复杂度是O(n2)。(12)以下说法错误的是（）。构时实现的效率低B．顺序存储的线性表可以随机存取C．由于顺序存储要求连续的存储区域，所以在存储管理上不够灵活D．线性表的链式存储结构优于顺序存储结构A．求表长、定位这两种运算在采用顺序存储结构时实现的效率不比采用链式存储结答案：D解释：链式存储结构和顺序存储结构各有优缺点，有不同的适用场合。(13)在单链表中，要将s所指结点插入到p所指结点之后，其语句应为（）。6A．s->next=p+1;p->next=s;B．(*p).next=s;(*s).next=(*p).next;C．s->next=p->next;p->next=s->next;D．s->next=p->next;p->next=s;答案：D(14)在双向链表存储结构中，删除p所指的结点时须修改指针（）。A．p->next->prior=p->prior;p->prior->next=p->next;B．p->next=p->next->next;p->next->prior=p;C．p->prior->next=p;p->prior=p->prior->prior;D．p->prior=p->next->next;p->next=p->prior->prior;答案：A(15)在双向循环链表中，在p指针所指的结点后插入q所指向的新结点，其修改指针的操作是（）。A．p->next=q; q->prior=p;p->next->prior=q;q->next=q;B．p->next=q;p->next->prior=q;q->prior=p;q->next=p->next;C．q->prior=p;q->next=p->next;p->next->prior=q;p->next=q;D．q->prior=p;q->next=p->next;p->next=q;p->next->prior=q;答案：C2．算法设计题（1）将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表的存储空间,不另外占用其它的存储空间。表中不允许有重复的数据。[题目分析]合并后的新表使用头指针Lc指向，pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点，从第一个结点开始进行比较，当两个链表La和Lb均为到达表尾结点时，依次摘取其中较小者重新链接在Lc表的最后。如果两个表中的元素相等，只摘取La表中的元素，删除Lb表中的元素，这样确保合并后表中无重复的元素。当一个表到达表尾结点，为空时，将非空表的剩余元素直接链接在Lc表的最后。[算法描述]void MergeList(LinkList &La,LinkList &Lb,LinkList &Lc){//合并链表La和Lb，合并后的新表使用头指针Lc指向pa=La->next;  pb=Lb->next;//pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点Lc=pc=La;  //用La的头结点作为Lc的头结点while(pa && pb){if(pa->data<pb->data){pc->next=pa;pc=pa;pa=pa->next;}//取较小者La中的元素，将pa链接在pc的后面，pa指针后移else if(pa->data>pb->data) {pc->next=pb; pc=pb; pb=pb->next;}//取较小者Lb中的元素，将pb链接在pc的后面，pb指针后移7else //相等时取La中的元素，删除Lb中的元素{pc->next=pa;pc=pa;pa=pa->next;q=pb->next;delete pb ;pb =q;}}pc->next=pa?pa:pb;    //插入剩余段delete Lb;            //释放Lb的头结点}（2）将两个非递减的有序链表合并为一个非递增的有序链表。要求结果链表仍使用原来两个链表的存储空间,不另外占用其它的存储空间。表中允许有重复的数据。[题目分析]合并后的新表使用头指针Lc指向，pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点，从第一个结点开始进行比较，当两个链表La和Lb均为到达表尾结点时，依次摘取其中较小者重新链接在Lc表的表头结点之后，如果两个表中的元素相等，只摘取La表中的元素，保留Lb表中的元素。当一个表到达表尾结点，为空时，将非空表的剩余元素依次摘取，链接在Lc表的表头结点之后。[算法描述]void MergeList(LinkList& La, LinkList& Lb, LinkList& Lc, ){//合并链表La和Lb，合并后的新表使用头指针Lc指向pa=La->next;  pb=Lb->next;//pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点Lc=pc=La; //用La的头结点作为Lc的头结点Lc->next=NULL;while(pa||pb ){//只要存在一个非空表，用q指向待摘取的元素if(!pa)  {q=pb;  pb=pb->next;}//La表为空，用q指向pb，pb指针后移else if(!pb)  {q=pa;  pa=pa->next;}//Lb表为空，用q指向pa，pa指针后移else if(pa->data<=pb->data)  {q=pa;  pa=pa->next;}//取较小者（包括相等）La中的元素，用q指向pa，pa指针后移else {q=pb;  pb=pb->next;}//取较小者Lb中的元素，用q指向pb，pb指针后移q->next = Lc->next;  Lc->next = q;//将q指向的结点插在Lc表的表头结点之后}delete Lb;             //释放Lb的头结点}8（3）已知两个链表A和B分别表示两个集合，其元素递增排列。请设计算法求出A与B的交集，并存放于A链表中。[题目分析]只有同时出现在两集合中的元素才出现在结果表中,合并后的新表使用头指针Lc指向。pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点，从第一个结点开始进行比较，当两个链表La和Lb均为到达表尾结点时，如果两个表中相等的元素时，摘取La表中的元素，删除Lb表中的元素；如果其中一个表中的元素较小时，删除此表中较小的元素，此表的工作指针后移。当链表La和Lb有一个到达表尾结点，为空时，依次删除另一个非空表中的所有元素。[算法描述]void Mix(LinkList& La, LinkList& Lb, LinkList& Lc){pa=La->next;pb=Lb->next;pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点Lc=pc=La; //用La的头结点作为Lc的头结点while(pa&&pb){ if(pa->data==pb->data)∥交集并入结果表中。{ pc->next=pa;pc=pa;pa=pa->next;u=pb;pb=pb->next; delete u;}else if(pa->data<pb->data) {u=pa;pa=pa->next; delete u;}else {u=pb; pb=pb->next; delete u;}}while(pa){u=pa; pa=pa->next; deleteu;}∥ 释放结点空间while(pb) {u=pb; pb=pb->next; delete u;}∥释放结点空间pc->next=null;∥置链表尾标记。delete Lb;  //释放Lb的头结点}（4）已知两个链表A和B分别表示两个集合，其元素递增排列。请设计算法求出两个集合A和B的差集（即仅由在A中出现而不在B中出现的元素所构成的集合），并以同样的形式存储，同时返回该集合的元素个数。[题目分析]求两个集合A和B的差集是指在A中删除A和B中共有的元素，即删除链表中的相应结点,所以要保存待删除结点的前驱，使用指针pre指向前驱结点。pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点，从第一个结点开始进行比较，当两个链表La和Lb均为到达表尾结点时，如果La表中的元素小于Lb表中的元素，pre置为La表的工作指针pa删除Lb表中的元素；如果其中一个表中的元素较小时，删除此表中较小的元素，此表的工作指针后移。当链表La和Lb有一个为空时，依次删除另一个非空表中的所有元素。[算法描述]9void Difference（LinkList& La, LinkList& Lb,int *n）{∥差集的结果存储于单链表La中，*n是结果集合中元素个数，调用时为0pa=La->next; pb=Lb->next;∥pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点pre=La;∥pre为La中pa所指结点的前驱结点的指针while（pa&&pb）{if（pa->data<q->data）{pre=pa;pa=pa->next;*n++;}∥A链表中当前结点指针后移else if（pa->data>q->data）q=q->next;∥B链表中当前结点指针后移else {pre->next=pa->next;∥处理A，B中元素值相同的结点，应删除u=pa; pa=pa->next;delete u;}∥删除结点}}（5）设计算法将一个带头结点的单链表A分解为两个具有相同结构的链表B、C，其中B表的结点为A表中值小于零的结点，而C表的结点为A表中值大于零的结点（链表A中的元素为非零整数，要求B、C表利用A表的结点）。[题目分析]B表的头结点使用原来A表的头结点，为C表新申请一个头结点。从A表的第一个结点开始，依次取其每个结点p，判断结点p的值是否小于0，利用前插法，将小于0的结点插入B表,大于等于0的结点插入C表。[算法描述]void DisCompose(LinkedList A){  B=A;B->next= NULL;∥B表初始化C=newLNode;∥为C申请结点空间C->next=NULL;∥C初始化为空表p=A->next;∥p为工作指针while(p!= NULL){r=p->next;∥暂存p的后继if(p->data<0){p->next=B->next; B->next=p; }∥将小于0的结点链入B表,前插法else{p->next=C->next;C->next=p;}∥将大于等于0的结点链入C表,前插法p=r;∥p指向新的待处理结点。}}（6）设计一个算法，通过一趟遍历在单链表中确定值最大的结点。[题目分析]10假定第一个结点中数据具有最大值，依次与下一个元素比较，若其小于下一个元素，则设其下一个元素为最大值，反复进行比较，直到遍历完该链表。[算法描述]ElemType Max (LinkList L ){if(L->next==NULL) return NULL;pmax=L->next; //假定第一个结点中数据具有最大值p=L->next->next;while(p != NULL ){//如果下一个结点存在}return pmax->data;if(p->data > pmax->data) pmax=p;//如果p的值大于pmax的值，则重新赋值p=p->next;//遍历链表（7）设计一个算法，通过遍历一趟，将链表中所有结点的链接方向逆转，仍利用原表的存储空间。[题目分析]从首元结点开始，逐个地把链表L的当前结点p插入新的链表头部。[算法描述]void  inverse(LinkList &L){//逆置带头结点的单链表Lp=L->next;  L->next=NULL;while ( p) {q=p->next;    // q指向*p的后继p->next=L->next;L->next=p;       // *p插入在头结点之后p = q;}}（8）设计一个算法，删除递增有序链表中值大于mink且小于maxk的所有元素（mink和maxk是给定的两个参数，其值可以和表中的元素相同，也可以不同）。[题目分析]分别查找第一个值>mink的结点和第一个值≥maxk的结点，再修改指针，删除值大于mink且小于maxk的所有元素。[算法描述]void delete(LinkList &L, int mink, int maxk) {p=L->next; //首元结点while (p && p->data<=mink){ pre=p;  p=p->next; } //查找第一个值>mink的结点if (p)11{while (p && p->data<maxk)  p=p->next;//查找第一个值≥maxk的结点q=pre->next;   pre->next=p;  //修改指针while (q!=p){ s=q->next;  delete q;  q=s; } //释放结点空间}//if}（9）已知p指向双向循环链表中的一个结点，其结点结构为data、prior、next三个域，写出算法change(p),交换p所指向的结点和它的前缀结点的顺序。[题目分析]知道双向循环链表中的一个结点，与前驱交换涉及到四个结点（p结点，前驱结点，前驱的前驱结点，后继结点）六条链。[算法描述]void  Exchange（LinkedList p）∥p是双向循环链表中的一个结点，本算法将p所指结点与其前驱结点交换。{q=p->llink；q->llink->rlink=p；∥p的前驱的前驱之后继为pp->llink=q->llink；∥p的前驱指向其前驱的前驱。q->rlink=p->rlink；∥p的前驱的后继为p的后继。q->llink=p；∥p与其前驱交换p->rlink->llink=q；∥p的后继的前驱指向原p的前驱p->rlink=q；∥p的后继指向其原来的前驱}∥算法exchange结束。（10）已知长度为n的线性表A采用顺序存储结构，请写一时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除线性表中所有值为item的数据元素。[题目分析]在顺序存储的线性表上删除元素，通常要涉及到一系列元素的移动（删第i个元素，第i+1至第n个元素要依次前移）。本题要求删除线性表中所有值为item的数据元素，并未要求元素间的相对位置不变。因此可以考虑设头尾两个指针（i=1，j=n），从两端向中间移动，凡遇到值item的数据元素时，直接将右端元素左移至值为item的数据元素位置。[算法描述]void  Delete（ElemType A[ ]，int  n）∥A是有n个元素的一维数组，本算法删除A中所有值为item的元素。{i=1；j=n；∥设置数组低、高端指针（下标）。while（i<j）{while（i<j && A[i]!=item）i++；∥若值不为item，左移指针。if（i<j）while（i<j && A[j]==item）j--；∥若右端元素为item，指针左移if（i<j）A[i++]=A[j--]；}12第3章栈和队列1．选择题（1）若让元素1，2，3，4，5依次进栈，则出栈次序不可能出现在（）种情况。A．5，4，3，2，1B．2，1，5，4，3C．4，3，1，2，5D．2，3，5，4，1答案：C解释：栈是后进先出的线性表，不难发现C选项中元素1比元素2先出栈，违背了栈的后进先出原则，所以不可能出现C选项所示的情况。（2）若已知一个栈的入栈序列是1，2，3，„，n，其输出序列为p1，p2，p3，„，pn，若p1=n，则pi为（）。A．i               B．n-i C．n-i+1            D．不确定答案：C解释：栈是后进先出的线性表，一个栈的入栈序列是1，2，3，„，n，而输出序列的第一个元素为n，说明1，2，3，„，n一次性全部进栈，再进行输出，所以p1=n，p2=n-1，„，pi=n-i+1。（3）数组Ｑ［ｎ］用来表示一个循环队列，ｆ为当前队列头元素的前一位置，ｒ为队尾元素的位置，假定队列中元素的个数小于ｎ，计算队列中元素个数的公式为（）。A．r-f             B．(n+f-r)%n       C．n+r-fD．（n+r-f)%n答案：D解释：对于非循环队列，尾指针和头指针的差值便是队列的长度，而对于循环队列，差值可能为负数，所以需要将差值加上MAXSIZE（本题为n），然后与MAXSIZE（本题为n）求余，即（n+r-f)%n。（4）链式栈结点为：(data,link)，top指向栈顶.若想摘除栈顶结点，并将删除结点的值保存到x中,则应执行操作（）。A．x=top->data;top=top->link；C．x=top;top=top->link；答案：A解释：x=top->data将结点的值保存到x中，top=top->link栈顶指针指向栈顶下一结点，即摘除栈顶结点。（5）设有一个递归算法如下int fact(int n) {//n大于等于0if(n<=0) return 1;else return n*fact(n-1);}则计算fact(n)需要调用该函数的次数为（）。A．n+1B．n-1C．nD．n+2答案：A13B．top=top->link;x=top->link；D．x=top->link；解释：特殊值法。设n=0，易知仅调用一次fact(n)函数，故选A。（6）栈在（）中有所应用。A．递归调用B．函数调用C．表达式求值D．前三个选项都有答案：D解释：递归调用、函数调用、表达式求值均用到了栈的后进先出性质。（7）为解决计算机主机与打印机间速度不匹配问题，通常设一个打印数据缓冲区。主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是（）。A．队列B．栈C．线性表D．有序表答案：A解释：解决缓冲区问题应利用一种先进先出的线性表，而队列正是一种先进先出的线性表。（8）设栈S和队列Q的初始状态为空，元素e1、e2、e3、e4、e5和e6依次进入栈S，一个元素出栈后即进入Q，若6个元素出队的序列是e2、e4、e3、e6、e5和e1，则栈S的容量至少应该是（）。A．2B．3C．4D．6答案：B解释：元素出队的序列是e2、e4、e3、e6、e5和e1，可知元素入队的序列是e2、e4、e3、e6、e5和e1，即元素出栈的序列也是e2、e4、e3、e6、e5和e1，而元素e1、e2、e3、e4、e5和e6依次进入栈，易知栈S中最多同时存在3个元素，故栈S的容量至少为3。（9）若一个栈以向量V[1..n]存储，初始栈顶指针top设为n+1，则元素x进栈的正确操作是()。A．top++; V[top]=x;C．top--; V[top]=x;答案：C解释：初始栈顶指针top为n+1，说明元素从数组向量的高端地址进栈，又因为元素存储在向量空间V[1..n]中，所以进栈时top指针先下移变为n，之后将元素x存储在V[n]。（10）设计一个判别表达式中左，右括号是否配对出现的算法，采用（）数据结构最佳。A．线性表的顺序存储结构B．队列C.线性表的链式存储结构D.栈答案：D解释：利用栈的后进先出原则。（11）用链接方式存储的队列，在进行删除运算时（）。A.仅修改头指针B.仅修改尾指针C.头、尾指针都要修改D.头、尾指针可能都要修改答案：DB．V[top]=x; top++;D．V[top]=x; top--;14解释：一般情况下只修改头指针，但是，当删除的是队列中最后一个元素时，队尾指针也丢失了，因此需对队尾指针重新赋值。（12）循环队列存储在数组A[0..m]中，则入队时的操作为（）。A. rear=rear+1               B. rear=(rear+1)%(m-1)C. rear=(rear+1)%mD. rear=(rear+1)%(m+1)答案：D解释：数组A[0..m]中共含有m+1个元素，故在求模运算时应除以m+1。（13）最大容量为n的循环队列，队尾指针是rear，队头是front，则队空的条件是（）。A. (rear+1)%n==front                  B. rear==frontC．rear+1==front          D. (rear-l)%n==front答案：B解释：最大容量为n的循环队列，队满条件是(rear+1)%n==front，队空条件是rear==front。（14）栈和队列的共同点是（）。A.都是先进先出B.都是先进后出C.只允许在端点处插入和删除元素D.没有共同点答案：C解释：栈只允许在栈顶处进行插入和删除元素，队列只允许在队尾插入元素和在队头删除元素。（15）一个递归算法必须包括（）。A.递归部分B.终止条件和递归部分C.迭代部分D.终止条件和迭代部分答案：B2．算法设计题（1）将编号为0和1的两个栈存放于一个数组空间V[m]中，栈底分别处于数组的两端。当第0号栈的栈顶指针top[0]等于-1时该栈为空，当第1号栈的栈顶指针top[1]等于m时该栈为空。两个栈均从两端向中间增长。试编写双栈初始化，判断栈空、栈满、进栈和出栈等算法的函数。双栈数据结构的定义如下：Typedef struct{int top[2],bot[2];SElemType *V;int m;}DblStack[题目分析]两栈共享向量空间，将两栈栈底设在向量两端，初始时，左栈顶指针为-1，右栈顶为m。两栈顶指针相邻时为栈满。两栈顶相向、迎面增长，栈顶指针指向栈顶元素。[算法描述]15//栈顶和栈底指针//栈数组//栈最大可容纳元素个数(1)栈初始化int Init(){S.top[0]=-1;S.top[1]=m;return 1; //初始化成功}(2)入栈操作：int push(stk S ,int i,int x)∥i为栈号，i=0表示左栈，i=1为右栈，x是入栈元素。入栈成功返回1，失败返回0{if(i<0||i>1){cout<<“栈号输入不对”<<endl;exit(0);}if(S.top[1]-S.top[0]==1) {cout<<“栈已满”<<endl;return(0);}switch(i){case 0: S.V[++S.top[0]]=x; return(1); break;case 1: S.V[--S.top[1]]=x; return(1);}}∥push(3)退栈操作ElemType pop(stk S,int i)∥退栈。i代表栈号，i=0时为左栈，i=1时为右栈。退栈成功时返回退栈元素∥否则返回-1{if(i<0 || i>1){cout<<“栈号输入错误”<<endl；exit(0);}switch(i){case 0: if(S.top[0]==-1) {cout<<“栈空”<<endl；return（-1）；}else return(S.V[S.top[0]--]);case 1: if(S.top[1]==m {cout<<“栈空”<<endl; return(-1);}else return(S.V[S.top[1]++]);}∥switch}∥算法结束(4)判断栈空int Empty();{return (S.top[0]==-1 && S.top[1]==m);}[算法讨论]请注意算法中两栈入栈和退栈时的栈顶指针的计算。左栈是通常意义下的栈，而右栈入栈操作时，其栈顶指针左移（减1），退栈时，栈顶指针右移（加1）。（2）回文是指正读反读均相同的字符序列，如“abba”和“abdba”均是回文，但“good”不是回文。试写一个算法判定给定的字符向量是否为回文。(提示：将一半字符入栈)16[题目分析]将字符串前一半入栈，然后，栈中元素和字符串后一半进行比较。即将第一个出栈元素和后一半串中第一个字符比较，若相等，则再出栈一个元素与后一个字符比较，„„，直至栈空，结论为字符序列是回文。在出栈元素与串中字符比较不等时，结论字符序列不是回文。[算法描述]#define StackSize 100 //假定预分配的栈空间最多为100个元素typedef char DataType;//假定栈元素的数据类型为字符typedef struct{DataType data[StackSize];int top;}SeqStack;int IsHuiwen( char *t){//判断t字符向量是否为回文，若是，返回1，否则返回0SeqStack s;int i , len;char temp;InitStack( &s);len=strlen(t); //求向量长度for ( i=0; i<len/2; i++)//将一半字符入栈Push( &s, t[i]);while( !EmptyStack( &s)){//每弹出一个字符与相应字符比较temp=Pop (&s);if( temp!=S[i])return 0 ;//不等则返回0else i++;}return 1 ; //比较完毕均相等则返回1}（3）设从键盘输入一整数的序列：a1,a2,a3，…，an，试编写算法实现：用栈结构存储输入的整数，当ai≠-1时，将ai进栈；当ai=-1时，输出栈顶整数并出栈。算法应对异常情况（入栈满等）给出相应的信息。[算法描述]#define maxsize栈空间容量void InOutS(int s[maxsize])//s是元素为整数的栈，本算法进行入栈和退栈操作。{int top=0;             //top为栈顶指针，定义top=0时为栈空。for(i=1; i<=n; i++)    //n个整数序列作处理。17{cin>>x);    //从键盘读入整数序列。if(x!=-1)           //读入的整数不等于-1时入栈。｛if(top==maxsize-1){cout<<“栈满”<<endl;exit(0);}else s[++top]=x; //x入栈。｝else   //读入的整数等于-1时退栈。{if(top==0){cout<<“栈空”<<endl;exit(0);}else cout<<“出栈元素是”<<s[top--]<<endl;}}}//算法结束。（4）从键盘上输入一个后缀表达式，试编写算法计算表达式的值。规定：逆波兰表达式的长度不超过一行，以$符作为输入结束，操作数之间用空格分隔,操作符只可能有+、-、*、/四种运算。例如：234 34+2*$。[题目分析]逆波兰表达式(即后缀表达式)求值规则如下：设立运算数栈OPND,对表达式从左到右扫描(读入)，当表达式中扫描到数时，压入OPND栈。当扫描到运算符时，从OPND退出两个数，进行相应运算，结果再压入OPND栈。这个过程一直进行到读出表达式结束符$，这时OPND栈中只有一个数，就是结果。[算法描述]float expr( )//从键盘输入逆波兰表达式，以‘$’表示输入结束，本算法求逆波兰式表达式的值。｛float OPND[30];   // OPND是操作数栈。init(OPND);       //两栈初始化。float num=0.0;    //数字初始化。cin>>x;//x是字符型变量。while(x!=’$’){switchwhile((x>=’0’&&x<=’9’)||x==’.’)  //拼数if(x!=’.’)   //处理整数{num=num*10+（ord(x)-ord(‘0’)）; cin>>x;}else           //处理小数部分。{scale=10.0; cin>>x;while(x>=’0’&&x<=’9’){num=num+(ord(x)-ord(‘0’)/scale;scale=scale*10;  cin>>x; }}//else18{case‘0’<=x<=’9’:push(OPND,num); num=0.0;//数压入栈，下个数初始化case x=‘’:break;  //遇空格，继续读下一个字符。case x=‘+’:push(OPND,pop(OPND)+pop(OPND));break;case x=‘-’:x1=pop(OPND);x2=pop(OPND);push(OPND,x2-x1);break;case x=‘*’:push(OPND,pop(OPND)*pop(OPND));break;case x=‘/’:x1=pop(OPND);x2=pop(OPND);push(OPND,x2/x1);break;default:       //其它符号不作处理。}//结束switchcin>>x;//读入表达式中下一个字符。}//结束while（x！=‘$’）cout<<“后缀表达式的值为”<<pop(OPND);}//算法结束。[算法讨论]假设输入的后缀表达式是正确的，未作错误检查。算法中拼数部分是核心。若遇到大于等于‘0’且小于等于‘9’的字符，认为是数。这种字符的序号减去字符‘0’的序号得出数。对于整数，每读入一个数字字符，前面得到的部分数要乘上10再加新读入的数得到新的部分数。当读到小数点，认为数的整数部分已完，要接着处理小数部分。小数部分的数要除以10（或10的幂数）变成十分位，百分位，千分位数等等，与前面部分数相加。在拼数过程中，若遇非数字字符，表示数已拼完，将数压入栈中，并且将变量num恢复为0，准备下一个数。这时对新读入的字符进入‘+’、‘-’、‘*’、‘/’及空格的判断，因此在结束处理数字字符的case后，不能加入break语句。（5）假设以I和O分别表示入栈和出栈操作。栈的初态和终态均为空，入栈和出栈的操作序列可表示为仅由I和O组成的序列，称可以操作的序列为合法序列，否则称为非法序列。①下面所示的序列中哪些是合法的？A. IOIIOIOO     B. IOOIOIIO      C. IIIOIOIO     D. IIIOOIOO②通过对①的分析，写出一个算法，判定所给的操作序列是否合法。若合法，返回true，否则返回false（假定被判定的操作序列已存入一维数组中）。答案：①A和D是合法序列，B和C是非法序列。②设被判定的操作序列已存入一维数组A中。int Judge(char A[])//判断字符数组A中的输入输出序列是否是合法序列。如是，返回true，否则返回false。{i=0;                //i为下标。j=k=0;              //j和k分别为I和字母O的的个数。while(A[i]!=‘\0’) //当未到字符数组尾就作。{switch(A[i]){case‘I’: j++; break; //入栈次数增1。19case‘O’: k++; if(k>j){cout<<“序列非法”<<ednl；exit(0);}}i++; //不论A[i]是‘I’或‘O’，指针i均后移。}if(j!=k) {cout<<“序列非法”<<endl；return(false);}else {cout<<“序列合法”<<endl；return(true);}}//算法结束。[算法讨论]在入栈出栈序列（即由‘I’和‘O’组成的字符串）的任一位置，入栈次数（‘I’的个数）都必须大于等于出栈次数（即‘O’的个数），否则视作非法序列，立即给出信息，退出算法。整个序列（即读到字符数组中字符串的结束标记‘\0’），入栈次数必须等于出栈次数（题目中要求栈的初态和终态都为空），否则视为非法序列。(6）假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素站点(注意不设头指针)，试编写相应的置空队、判队空、入队和出队等算法。[题目分析]置空队就是建立一个头节点，并把头尾指针都指向头节点，头节点是不存放数据的；判队空就是当头指针等于尾指针时，队空；入队时，将新的节点插入到链队列的尾部，同时将尾指针指向这个节点；出队时，删除的是队头节点，要注意队列的长度大于1还是等于1的情况，这个时候要注意尾指针的修改，如果等于1，则要删除尾指针指向的节点。[算法描述]//先定义链队结构:typedef struct queuenode{Datatype data;struct queuenode *next;}QueueNode; //以上是结点类型的定义typedef struct{queuenode *rear;}LinkQueue; //只设一个指向队尾元素的指针(1)置空队void InitQueue( LinkQueue *Q){ //置空队：就是使头结点成为队尾元素QueueNode *s;Q->rear = Q->rear->next;//将队尾指针指向头结点while (Q->rear!=Q->rear->next)//当队列非空，将队中元素逐个出队{s=Q->rear->next;Q->rear->next=s->next;delete s;}//回收结点空间20}(2)判队空int EmptyQueue( LinkQueue *Q){ //判队空。当头结点的next指针指向自己时为空队return Q->rear->next->next==Q->rear->next;}(3)入队void EnQueue( LinkQueue *Q, Datatype x){ //入队。也就是在尾结点处插入元素QueueNode *p=new QueueNode;//申请新结点p->data=x; p->next=Q->rear->next;//初始化新结点并链入Q-rear->next=p;Q->rear=p;//将尾指针移至新结点}(4)出队Datatype DeQueue( LinkQueue *Q){//出队,把头结点之后的元素摘下Datatype t;QueueNode *p;if(EmptyQueue( Q ))Error("Queue underflow");p=Q->rear->next->next; //p指向将要摘下的结点x=p->data; //保存结点中数据if (p==Q->rear){//当队列中只有一个结点时，p结点出队后，要将队尾指针指向头结点Q->rear = Q->rear->next;Q->rear->next=p->next;}elseQ->rear->next->next=p->next;//摘下结点pdelete p;//释放被删结点return x;}21（7）假设以数组Q[m]存放循环队列中的元素,同时设置一个标志tag，以tag==0和tag==1来区别在队头指针(front)和队尾指针(rear)相等时，队列状态为“空”还是“满”。试编写与此结构相应的插入(enqueue)和删除(dlqueue)算法。[算法描述](1)初始化SeQueue QueueInit(SeQueue Q){//初始化队列Q.front=Q.rear=0; Q.tag=0;returnQ;}(2)入队SeQueue QueueIn(SeQueue Q,int e){//入队列if((Q.tag==1) && (Q.rear==Q.front)) cout<<"队列已满"<<endl;else{Q.rear=(Q.rear+1) % m;Q.data[Q.rear]=e;if(Q.tag==0) Q.tag=1; //队列已不空}returnQ;}(3)出队ElemType QueueOut(SeQueue Q){//出队列if(Q.tag==0) { cout<<"队列为空"<<endl; exit(0);}else{Q.front=(Q.front+1) % m;e=Q.data[Q.front];if(Q.front==Q.rear) Q.tag=0;//空队列}return(e);}(8）如果允许在循环队列的两端都可以进行插入和删除操作。要求：①写出循环队列的类型定义；②写出“从队尾删除”和“从队头插入”的算法。[题目分析]用一维数组v[0..M-1]实现循环队列，其中M是队列长度。设队头指针front和队尾指针rear，约定front指向队头元素的前一位置，rear指向队尾元素。定义22front=rear时为队空，(rear+1)%m=front为队满。约定队头端入队向下标小的方向发展，队尾端入队向下标大的方向发展。[算法描述]①#define M队列可能达到的最大长度typedef struct{elemtp data[M];int front,rear;}cycqueue;②elemtp delqueue ( cycqueue Q)//Q是如上定义的循环队列，本算法实现从队尾删除，若删除成功，返回被删除元素，否则给出出错信息。{if (Q.front==Q.rear)  {cout<<"队列空"<<endl; exit(0);}Q.rear=(Q.rear-1+M)%M;          //修改队尾指针。return(Q.data[(Q.rear+1+M)%M]); //返回出队元素。}//从队尾删除算法结束void enqueue (cycqueue Q, elemtp x)// Q是顺序存储的循环队列，本算法实现“从队头插入”元素x。{if(Q.rear==(Q.front-1+M)%M)  {cout<<"队满"<<endl; exit(0);)Q.data[Q.front]=x;        //x入队列Q.front=(Q.front-1+M)%M;  //修改队头指针。}//结束从队头插入算法。（9）已知Ackermann函数定义如下:①写出计算Ack(m,n)的递归算法，并根据此算法给出出Ack(2,1)的计算过程。②写出计算Ack(m,n)的非递归算法。[算法描述]int Ack(int m,n){if (m==0) return(n+1);else if(m!=0&&n==0) return(Ack(m-1,1));else return(Ack(m-1,Ack(m,m-1));}//算法结束①Ack(2,1)的计算过程23Ack(2,1)=Ack(1,Ack(2,0))           //因m<>0,n<>0而得②int Ackerman(int m, int n){int akm[M][N];int i,j;for(j=0;j<N;j++) akm[0][j]=j+1;for(i=1;i<m;i++){akm[i][0]=akm[i-1][1];for(j=1;j<N;j++)akm[i][j]=akm[i-1][akm[i][j-1]];}return(akm[m][n]);}//算法结束（10）已知f为单链表的表头指针,链表中存储的都是整型数据，试写出实现下列运算的递归算法：①求链表中的最大整数；②求链表的结点个数；③求所有整数的平均值。[算法描述]①int GetMax(LinkList p){=Ack(1,Ack(1,1))            //因m<>0,n=0而得=Ack(1,Ack(0,Ack(1,0)))     //因m<>0,n<>0而得=Ack(1,Ack(0,Ack(0,1)))    //因m<>0,n=0而得=Ack(1,Ack(0,2))            //因m=0而得=Ack(1,3)                   //因m=0而得=Ack(0,Ack(1,2))            //因m<>0,n<>0而得= Ack(0,Ack(0,Ack(1,1)))    //因m<>0,n<>0而得= Ack(0,Ack(0,Ack(0,Ack(1,0)))) //因m<>0,n<>0而得= Ack(0,Ack(0,Ack(0,Ack(0,1)))) //因m<>0,n=0而得= Ack(0,Ack(0,Ack(0,2)))    //因m=0而得= Ack(0,Ack(0,3))           //因m=0而得= Ack(0,4)                  //因n=0而得=5                          //因n=0而得if(!p->next)else24return p->data;}{}int max=GetMax(p->next);return p->data>=max ? p->data:max;②int GetLength(LinkList p){}if(!p->next)else{}return GetLength(p->next)+1;return 1;③double GetAverage(LinkList p , int n){}if(!p->next)else{}double ave=GetAverage(p->next,n-1);return (ave*(n-1)+p->data)/n;return p->data;25第4章串、数组和广义表1．选择题（1）串是一种特殊的线性表，其特殊性体现在（）。A．可以顺序存储B．数据元素是一个字符C．可以链式存储D．数据元素可以是多个字符若答案：B（2）串下面关于串的的叙述中，（）是不正确的？A．串是字符的有限序列B．空串是由空格构成的串C．模式匹配是串的一种重要运算D．串既可以采用顺序存储，也可以采用链式存储答案：B解释：空格常常是串的字符集合中的一个元素，有一个或多个空格组成的串成为空格串，零个字符的串成为空串，其长度为零。（3）串“ababaaababaa”的next数组为（）。A．012345678999B．012121111212C．011234223456D．0123012322345答案：C（4）串“ababaabab”的nextval为（）。A．010104101B．010102101C．010100011D．010101011答案：A（5）串的长度是指（）。A．串中所含不同字母的个数B．串中所含字符的个数C．串中所含不同字符的个数D．串中所含非空格字符的个数答案：B解释：串中字符的数目称为串的长度。（6）假设以行序为主序存储二维数组A=array[1..100,1..100]，设每个数据元素占2个存储单元，基地址为10，则LOC[5,5]=（）。A．808B．818C．1010D．1020答案：B解释：以行序为主，则LOC[5,5]=[（5-1）*100+（5-1）]*2+10=818。（7）设有数组A[i,j]，数组的每个元素长度为3字节，i的值为1到8，j的值为1到10，数组从内存首地址BA开始顺序存放，当用以列为主存放时，元素A[5,8]的存储首地址为（）。A．BA+141B．BA+180C．BA+222D．BA+225答案：B解释：以列序为主，则LOC[5,8]=[（8-1）*8+（5-1）]*3+BA=BA+180。（8）设有一个10阶的对称矩阵A，采用压缩存储方式，以行序为主存储，a11为第一元素，其存储地址为1，每个元素占一个地址空间，则a85的地址为（）。26A．13B．32C．33D．40答案：C（9）若对n阶对称矩阵A以行序为主序方式将其下三角形的元素(包括主对角线上所有元素)依次存放于一维数组B[1..(n(n+1))/2]中，则在B中确定aij（i<j）的位置k的关系为（）。A．i*(i-1)/2+jB．j*(j-1)/2+iC．i*(i+1)/2+jD．j*(j+1)/2+i答案：B（10）二维数组A的每个元素是由10个字符组成的串，其行下标i=0,1,„,8,列下标j=1,2,„,10。若A按行先存储，元素A[8,5]的起始地址与当A按列先存储时的元素（）的起始地址相同。设每个字符占一个字节。A．A[8,5]B．A[3,10]C. A[5,8]D．A[0,9]答案：B解释：设数组从内存首地址M开始顺序存放，若数组按行先存储，元素A[8,5]的起始地址为：M+[（8-0）*10+（5-1）]*1=M+84；若数组按列先存储，易计算出元素A[3,10]的起始地址为：M+[（10-1）*9+（3-0）]*1=M+84。故选B。（11）设二维数组A[1.. m，1.. n]（即m行n列）按行存储在数组B[1.. m*n]中，则二维数组元素A[i,j]在一维数组B中的下标为（）。A．(i-1)*n+jB．(i-1)*n+j-1C．i*(j-1) D．j*m+i-1答案：A解释：特殊值法。取i=j=1，易知A[1,1]的的下标为1，四个选项中仅有A选项能确定的值为1，故选A。（12）数组A[0..4,-1..-3,5..7]中含有元素的个数（）。A．55B．45C．36D．16答案：B解释：共有5*3*3=45个元素。（13）广义表A=(a,b,(c,d),(e,(f,g)))，则Head(Tail(Head(Tail(Tail(A)))))的值为（）。A．(g)B．(d)C．cD．d答案：D解释：Tail(A)=(b,(c,d),(e,(f,g)))；Tail(Tail(A))=((c,d),(e,(f,g)))；Head(Tail(Tail(A)))=(c,d)；Tail(Head(Tail(Tail(A))))=(d)；Head(Tail(Head(Tail(Tail(A)))))=d。（14）广义表((a,b,c,d))的表头是（），表尾是（）。A．aB．( )C．(a,b,c,d)D．(b,c,d)答案：C、B解释：表头为非空广义表的第一个元素，可以是一个单原子，也可以是一个子表，((a,b,c,d))的表头为一个子表(a,b,c,d)；表尾为除去表头之外，由其余元素构成的表，表为一定是个广义表，((a,b,c,d))的表尾为空表( )。（15）设广义表L=((a,b,c))，则L的长度和深度分别为（）。A．1和1B．1和3C．1和2D．2和3答案：C27解释：广义表的深度是指广义表中展开后所含括号的层数，广义表的长度是指广义表中所含元素的个数。根据定义易知L的长度为1，深度为2。2．应用题（1）已知模式串t=‘abcaabbabcab’写出用KMP法求得的每个字符对应的next和nextval函数值。答案：模式串t的next和nextval值如下：jt串next[j]nextval[j]（2）设目标为t=“abcaabbabcabaacbacba”,模式为p=“abcabaa”①计算模式p的naxtval函数值；②不写出算法,只画出利用KMP算法进行模式匹配时每一趟的匹配过程。答案：①p的nextval函数值为0110132。（p的next函数值为0111232）。②利用KMP(改进的nextval)算法，每趟匹配过程如下：第一趟匹配：abcaabbabcabaacbacbaabcab(i=5,j=5)第二趟匹配：abcaabbabcabaacbacbaabc(i=7,j=3)第三趟匹配：abcaabbabcabaacbacbaa(i=7,j=1)第四趟匹配：abcaabbabcabaac bacba(成功)             abcabaa(i=15,j=8)（3）数组A中，每个元素A[i,j]的长度均为32个二进位,行下标从-1到9，列下标从1到11，从首地址S开始连续存放主存储器中，主存储器字长为16位。求：①存放该数组所需多少单元？②存放数组第4列所有元素至少需多少单元？③数组按行存放时，元素A[7,4]的起始地址是多少？④数组按列存放时，元素A[4,7]的起始地址是多少？答案：每个元素32个二进制位，主存字长16位，故每个元素占2个字长，行下标可平移至1到11。（1）242（2）22（3）s+182（4）s+142281234 5678910 11 12abcaabbabcab011122312345011021301105(4)请将香蕉banana用工具H( )—Head( )，T( )—Tail( )从L中取出。L=(apple,(orange,(strawberry,(banana)),peach),pear)答案：H（H（T（H（T（H（T（L）））））））3．算法设计题（1）写一个算法统计在输入字符串中各个不同字符出现的频度并将结果存入文件（字符串中的合法字符为A-Z这26个字母和0-9这10个数字）。[题目分析]由于字母共26个，加上数字符号10个共36个，所以设一长36的整型数组，前10个分量存放数字字符出现的次数，余下存放字母出现的次数。从字符串中读出数字字符时，字符的ASCII代码值减去数字字符‘0’的ASCII代码值，得出其数值(0..9)，字母的ASCII代码值减去字符‘A’的ASCII代码值加上10，存入其数组的对应下标分量中。遇其它符号不作处理，直至输入字符串结束。[算法描述]void Count（）//统计输入字符串中数字字符和字母字符的个数。｛int i，num[36]；char ch；for（i＝0；i<36；i++）num[i]＝０；//初始化while（（ch＝getchar（））!=‘#’）//‘#’表示输入字符串结束。if（‘0’<=ch<=‘9’）｛i=ch－48;num[i]++；｝//数字字符elseif（‘A’<=ch<=‘Z’）｛i=ch-65+10;num[i]++；｝//字母字符for（i=0；i<10；i++）//输出数字字符的个数（2）写一个递归算法来实现字符串逆序存储，要求不另设串存储空间。[题目分析]实现字符串的逆置并不难，但本题“要求不另设串存储空间”来实现字符串逆序存储，即第一个输入的字符最后存储，最后输入的字符先存储，使用递归可容易做到。[算法描述]voidInvertStore(charA[])//字符串逆序存储的递归算法。{charch;staticinti = 0;//需要使用静态变量cin>>ch;if (ch!= '.')    //规定'.'是字符串输入结束标志29｝cout<<“数字”<<i<<“的个数=”<<num[i]<<endl;cout<<“字母字符”<<i+55<<“的个数=”<<num[i]<<endl;for（i＝10；i<36；i++）//求出字母字符的个数}{InvertStore(A);A[i++] = ch;//字符串逆序存储}A[i] = '\0';  //字符串结尾标记（3）编写算法，实现下面函数的功能。函数void insert(char*s,char*t,int pos)将字符串t插入到字符串s中，插入位置为pos。假设分配给字符串s的空间足够让字符串t插入。（说明：不得使用任何库函数）[题目分析]本题是字符串的插入问题，要求在字符串s的pos位置，插入字符串t。首先应查找字符串s的pos位置，将第pos个字符到字符串s尾的子串向后移动字符串t的长度，然后将字符串t复制到字符串s的第pos位置后。对插入位置pos要验证其合法性，小于1或大于串s的长度均为非法，因题目假设给字符串s的空间足够大，故对插入不必判溢出。[算法描述]void  insert(char *s,char *t,int pos)//将字符串t插入字符串s的第pos个位置。{int i=1,x=0;  char *p=s,*q=t;  //p，q分别为字符串s和t的工作指针if(pos<1) {cout<<“pos参数位置非法”<<endl;exit(0);}while(*p!=’\0’&&i<pos) {p++;i++;} //查pos位置//若pos小于串s长度，则查到pos位置时，i=pos。if(*p == '/0') {cout<<pos<<"位置大于字符串s的长度";exit(0);}else      //查找字符串的尾while(*p!='/0'){p++;i++;}  //查到尾时，i为字符‘\0’的下标，p也指向‘\0’。while(*q!='\0'){q++;x++;}   //查找字符串t的长度x，循环结束时q指向'\0'。for(j=i;j>=pos ;j--){*(p+x)=*p; p--;}//串s的pos后的子串右移，空出串t的位置。q--;  //指针q回退到串t的最后一个字符for(j=1;j<=x;j++) *p--=*q--;  //将t串插入到s的pos位置上[算法讨论]串s的结束标记('\0')也后移了，而串t的结尾标记不应插入到s中。（4）已知字符串S1中存放一段英文，写出算法format(s1,s2,s3,n),将其按给定的长度n格式化成两端对齐的字符串S2,其多余的字符送S3。[题目分析]本题要求字符串s1拆分成字符串s2和字符串s3，要求字符串s2“按给定长度n格式化成两端对齐的字符串”，即长度为n且首尾字符不得为空格字符。算法从左到右扫描字符串s1，找到第一个非空格字符，计数到n，第n个拷入字符串s2的字符不得为空格，然后将余下字符复制到字符串s3中。[算法描述]30void format (char *s1,*s2,*s3)//将字符串s1拆分成字符串s2和字符串s3，要求字符串s2是长n且两端对齐{char *p=s1, *q=s2;int i=0;}（5）设二维数组a[1..m, 1..n]含有m*n个整数。①写一个算法判断a中所有元素是否互不相同?输出相关信息(yes/no)；②试分析算法的时间复杂度。①[题目分析]判断二维数组中元素是否互不相同，只有逐个比较,找到一对相等的元素，就可结论为不是互不相同。如何达到每个元素同其它元素比较一次且只一次？在当前行，每个元素要同本行后面的元素比较一次（下面第一个循环控制变量p的for循环），然后同第i+1行及以后各行元素比较一次，这就是循环控制变量k和p的二层for循环。[算法描述]int JudgEqual(ing a[m][n],int m,n)//判断二维数组中所有元素是否互不相同，如是，返回1；否则，返回0。{for(i=0;i<m;i++)for(j=0;j<n-1;j++){for(p=j+1;p<n;p++) //和同行其它元素比较if(a[i][j]==a[i][p]) {cout<<“no”; return(0); }//只要有一个相同的，就结论不是互不相同31while(*p!= '\0' && *p== ' ') p++;//滤掉s1左端空格if(*p== '\0') {cout<<"字符串s1为空串或空格串"<<endl;exit(0);}while( *p!='\0' && i<n){*q=*p; q++; p++; i++;}//字符串s1向字符串s2中复制if(*p =='\0'){cout<<"字符串s1没有"<<n<<"个有效字符"<<endl; exit(0);}if(*(--q)==' ' ) //若最后一个字符为空格，则需向后找到第一个非空格字符{p-- ;          //p指针也后退while(*p==' '&&*p!='\0') p++;//往后查找一个非空格字符作串s2的尾字符if(*p=='\0'){cout<<"s1串没有"<<n<<"个两端对齐的字符串"<<endl; exit(0);}*q=*p;         //字符串s2最后一个非空字符*(++q)='\0';   //置s2字符串结束标记}*q=s3;p++;      //将s1串其余部分送字符串s3。while (*p!= '\0') {*q=*p; q++; p++;}*q='\0';        //置串s3结束标记for(k=i+1;k<m;k++)  //和第i+1行及以后元素比较for(p=0;p<n;p++)if(a[i][j]==a[k][p]) {cout<<“no”; return(0); }}// for(j=0;j<n-1;j++)cout<<“yes”; return(1);   //元素互不相同}//算法JudgEqual结束②二维数组中的每一个元素同其它元素都比较一次，数组中共m*n个元素，第1个元素同其它m*n-1个元素比较，第2个元素同其它m*n-2个元素比较，„„，第m*n-1个元素同最后一个元素(m*n)比较一次,所以在元素互不相等时总的比较次数为(m*n-1)+(m*n-2)+„+2+1=（m*n）(m*n-1)/2。在有相同元素时,可能第一次比较就相同,也可能最后一次比较时相同,设在(m*n-1)个位置上均可能相同,这时的平均比较次数约为（m*n）(m*n-1)/4，总的时间复杂度是O(n)。(6)设任意n个整数存放于数组A(1:n)中，试编写算法，将所有正数排在所有负数前面（要求算法复杂度为0(n)）。[题目分析]本题属于排序问题，只是排出正负，不排出大小。可在数组首尾设两个指针i和j，i自小至大搜索到负数停止，j自大至小搜索到正数停止。然后i和j所指数据交换，继续以上过程，直到i=j为止。[算法描述]void Arrange(int A[],int n)//n个整数存于数组A中，本算法将数组中所有正数排在所有负数的前面{int i=0,j=n-1,x;  //用类C编写，数组下标从0开始while(i<j){while(i<j && A[i]>0)  i++;while(i<j && A[j]<0)  j--;if(i<j) {x=A[i]; A[i++]=A[j]; A[j--]=x; }//交换A[i]与A[j]}// while(i<j)}//算法Arrange结束.[算法讨论]对数组中元素各比较一次，比较次数为n。最佳情况(已排好,正数在前,负数在后)不发生交换，最差情况(负数均在正数前面)发生n/2次交换。用类c编写，数组界偶是0..n-1。空间复杂度为O(1).324第5章树和二叉树1．选择题（1）把一棵树转换为二叉树后，这棵二叉树的形态是（）。A．唯一的Ｂ．有多种C．有多种，但根结点都没有左孩子Ｄ．有多种，但根结点都没有右孩子答案：A解释：因为二叉树有左孩子、右孩子之分，故一棵树转换为二叉树后，这棵二叉树的形态是唯一的。（2）由3个结点可以构造出多少种不同的二叉树？（）A．2       B．3         C．4      D．5答案：D解释：五种情况如下：AABCABCABCABCBC（3）一棵完全二叉树上有1001个结点，其中叶子结点的个数是（）。A．250   B．500    C．254     D．501答案：D解释：设度为0结点（叶子结点）个数为A，度为1的结点个数为B，度为2的结点个数为C，有A=C+1，A+B+C=1001，可得2C+B=1000，由完全二叉树的性质可得B=0或1，又因为C为整数，所以B=0，C=500，A=501，即有501个叶子结点。（4）一个具有1025个结点的二叉树的高h为（）。A．11        B．10     C．11至1025之间D．10至1024之间答案：C解释：若每层仅有一个结点，则树高h为1025；且其最小树高为log21025+ 1=11，即h在11至1025之间。（5）深度为h的满m叉树的第k层有（）个结点。(1=<k=<h)A．mk-1B．m-1          C．mD．m-1hk-1kh-1h答案：A解释：深度为h的满m叉树共有m-1个结点，第k层有m（6）利用二叉链表存储树，则根结点的右指针是（）。A．指向最左孩子B．指向最右孩子C．空D．非空答案：C个结点。33解释：利用二叉链表存储树时，右指针指向兄弟结点，因为根节点没有兄弟结点，故根节点的右指针指向空。（7）对二叉树的结点从1开始进行连续编号，要求每个结点的编号大于其左、右孩子的编号，同一结点的左右孩子中，其左孩子的编号小于其右孩子的编号，可采用（）遍历实现编号。A．先序B.中序C.后序D.从根开始按层次遍历答案：C解释：根据题意可知按照先左孩子、再右孩子、最后双亲结点的顺序遍历二叉树，即后序遍历二叉树。（8）若二叉树采用二叉链表存储结构，要交换其所有分支结点左、右子树的位置，利用（）遍历方法最合适。A．前序B．中序C．后序D．按层次答案：C解释：后续遍历和层次遍历均可实现左右子树的交换，不过层次遍历的实现消耗比后续大，后序遍历方法最合适。（9）在下列存储形式中，（）不是树的存储形式？A．双亲表示法B．孩子链表表示法C．孩子兄弟表示法D．顺序存储表示法答案：D解释：树的存储结构有三种：双亲表示法、孩子表示法、孩子兄弟表示法，其中孩子兄弟表示法是常用的表示法，任意一棵树都能通过孩子兄弟表示法转换为二叉树进行存储。（10）一棵非空的二叉树的先序遍历序列与后序遍历序列正好相反，则该二叉树一定满足（）。A．所有的结点均无左孩子B．所有的结点均无右孩子C．只有一个叶子结点D．是任意一棵二叉树答案：C解释：因为先序遍历结果是“中左右”，后序遍历结果是“左右中”，当没有左子树时，就是“中右”和“右中”；当没有右子树时，就是“中左”和“左中”。则所有的结点均无左孩子或所有的结点均无右孩子均可，所以A、B不能选，又所有的结点均无左孩子与所有的结点均无右孩子时，均只有一个叶子结点，故选C。（11）设哈夫曼树中有199个结点，则该哈夫曼树中有（）个叶子结点。A．99C．101答案：B解释：在哈夫曼树中没有度为1的结点，只有度为0（叶子结点）和度为2的结点。设叶子结点的个数为n0，度为2的结点的个数为n2，由二叉树的性质n0=n2+1，则总结点数n=n0+n2=2*n0-1，得到n0=100。（12）若X是二叉中序线索树中一个有左孩子的结点，且X不为根，则X的前驱为（）。A．X的双亲B．X的右子树中最左的结点34B．100D．102C．X的左子树中最右结点D．X的左子树中最右叶结点答案：C（13）引入二叉线索树的目的是（）。A．加快查找结点的前驱或后继的速度B．为了能在二叉树中方便的进行插入与删除C．为了能方便的找到双亲D．使二叉树的遍历结果唯一答案：A（14）设F是一个森林，B是由F变换得的二叉树。若F中有n个非终端结点，则B中右指针域为空的结点有（）个。A．n−1答案：C（15）n（n≥2）个权值均不相同的字符构成哈夫曼树，关于该树的叙述中，错误的是（）。A．该树一定是一棵完全二叉树B．树中一定没有度为1的结点C．树中两个权值最小的结点一定是兄弟结点D．树中任一非叶结点的权值一定不小于下一层任一结点的权值答案：A解释：哈夫曼树的构造过程是每次都选取权值最小的树作为左右子树构造一棵新的二叉树，所以树中一定没有度为1的结点、两个权值最小的结点一定是兄弟结点、任一非叶结点的权值一定不小于下一层任一结点的权值。2．应用题（1）试找出满足下列条件的二叉树①先序序列与后序序列相同②中序序列与后序序列相同③先序序列与中序序列相同④中序序列与层次遍历序列相同答案：先序遍历二叉树的顺序是“根—左子树—右子树”，中序遍历“左子树—根—右子树”，后序遍历顺序是：“左子树—右子树―根＂，根据以上原则有①或为空树，或为只有根结点的二叉树②或为空树，或为任一结点至多只有左子树的二叉树．③或为空树，或为任一结点至多只有右子树的二叉树．④或为空树，或为任一结点至多只有右子树的二叉树（2）设一棵二叉树的先序序列：A B D F C E G H，中序序列：B F D A G E H C①画出这棵二叉树。②画出这棵二叉树的后序线索树。③将这棵二叉树转换成对应的树（或森林）。答案：35B．nC．n + 1D．n + 2AABCBADECHBDF①②CEnullFDEFGGHGH③（3）假设用于通信的电文仅由8个字母组成，字母在电文中出现的频率分别为0.07，0.19，0.02，0.06，0.32，0.03，0.21，0.10。①试为这8个字母设计赫夫曼编码。②试设计另一种由二进制表示的等长编码方案。③对于上述实例，比较两种方案的优缺点。答案：方案1；哈夫曼编码先将概率放大100倍，以方便构造哈夫曼树。w={7,19,2,6,32,3,21,10}，按哈夫曼规则：【[（2,3），6], (7,10)】,„„19,21,32（100）（40）（60）192132（28）（17）（11）7106（5）230101011921320101 01710 6012336方案比较：字母编号123456方案1的WPL＝2(0.19+0.32+0.21)+4(0.07+0.06+0.10)+5(0.02+0.03)=1.44+0.92+0.25=2.61方案2的WPL＝3(0.19+0.32+0.21+0.07+0.06+0.10+0.02+0.03)=3结论：哈夫曼编码优于等长二进制编码（4）已知下列字符A、B、C、D、E、F、G的权值分别为3、12、7、4、2、8，11，试填写出其对应哈夫曼树HT的存储结构的初态和终态。答案：初态:1234567891011121337对应编码1100001111011101011111011101出现频率0.070.190.020.060.320.030.210.10字母编号12345678对应编码000001010011100101110111出现频率0.070.190.020.060.320.030.210.1078weight312742811parent0000000000000lchild0000000000000rchild0000000000000终态：123456789101112133．算法设计题以二叉链表作为二叉树的存储结构，编写以下算法：（1）统计二叉树的叶结点个数。[题目分析]如果二叉树为空，返回0，如果二叉树不为空且左右子树为空，返回1，如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数。[算法描述]int LeafNodeCount(BiTree T){}（2）判别两棵树是否相等。[题目分析]先判断当前节点是否相等(需要处理为空、是否都为空、是否相等)，如果当前节点不相等，直接返回两棵树不相等;如果当前节点相等，那么就递归的判断他们的左右孩子是否相等。38weight3127428115915202747parent812109810119111213130lchild00000005439211rchild000000018671012if(T==NULL)return 0; //如果是空树，则叶子结点个数为0return 1; //判断结点是否是叶子结点（左孩子右孩子都为空），若是则返回1return LeafNodeCount(T->lchild)+LeafNodeCount(T->rchild);else if(T->lchild==NULL&&T->rchild==NULL)else[算法描述]int compareTree(TreeNode* tree1, TreeNode* tree2)//用分治的方法做，比较当前根，然后比较左子树和右子树{bool tree1IsNull = (tree1==NULL);bool tree2IsNull = (tree2==NULL);if(tree1IsNull != tree2IsNull){return 1;}if(tree1IsNull && tree2IsNull){//如果两个都是NULL，则相等return 0;}//如果根节点不相等，直接返回不相等，否则的话，看看他们孩子相等不相等if(tree1->c != tree2->c){return 1;}return (compareTree(tree1->left,tree2->left)&compareTree(tree1->right,tree2->right))(compareTree(tree1->left,tree2->right)&compareTree(tree1->right,tree2->left));}//算法结束（3）交换二叉树每个结点的左孩子和右孩子。[题目分析]如果某结点左右子树为空，返回，否则交换该结点左右孩子，然后递归交换左右子树。[算法描述]void ChangeLR(BiTree &T){BiTree temp;if(T->lchild==NULL&&T->rchild==NULL)else{temp = T->lchild;T->lchild = T->rchild;T->rchild = temp;return;}//交换左右孩子ChangeLR(T->lchild);//递归交换左子树ChangeLR(T->rchild);//递归交换右子树39}（4）设计二叉树的双序遍历算法（双序遍历是指对于二叉树的每一个结点来说，先访问这个结点，再按双序遍历它的左子树，然后再一次访问这个结点，接下来按双序遍历它的右子树）。[题目分析]若树为空，返回；若某结点为叶子结点，则仅输出该结点；否则先输出该结点，递归遍历其左子树，再输出该结点，递归遍历其右子树。[算法描述]void DoubleTraverse(BiTree T){}（5）计算二叉树最大的宽度（二叉树的最大宽度是指二叉树所有层中结点个数的最大值）。[题目分析]求二叉树高度的算法见上题。求最大宽度可采用层次遍历的方法，记下各层结点数，每层遍历完毕，若结点数大于原先最大宽度，则修改最大宽度。[算法描述]int Width(BiTree bt)//求二叉树bt的最大宽度{if (bt==null) return (0);  //空二叉树宽度为0else{BiTree Q[];//Q是队列，元素为二叉树结点指针，容量足够大front=1;rear=1;last=1;//front队头指针,rear队尾指针,last同层最右结点在队列中的位置temp=0; maxw=0;       //temp记局部宽度, maxw记最大宽度Q[rear]=bt;           //根结点入队列while(front<=last){p=Q[front++]; temp++; //同层元素数加1if (p->lchild!=null)  Q[++rear]=p->lchild;   //左子女入队if (p->rchild!=null)  Q[++rear]=p->rchild;   //右子女入队if (front>last)      //一层结束，40if(T == NULL){}cout<<T->data;DoubleTraverse(T->lchild);   //递归遍历左子树cout<<T->data;DoubleTraverse(T->rchild);   //递归遍历右子树return;cout<<T->data;     //叶子结点输出else if(T->lchild==NULL&&T->rchild==NULL)else{last=rear;if(temp>maxw) maxw=temp;//last指向下层最右元素,更新当前最大宽度temp=0;}//if}//whilereturn (maxw);}//结束width（6）用按层次顺序遍历二叉树的方法，统计树中具有度为1的结点数目。[题目分析]若某个结点左子树空右子树非空或者右子树空左子树非空，则该结点为度为1的结点[算法描述]int Level(BiTree bt) //层次遍历二叉树，并统计度为1的结点的个数{int num=0; //num统计度为1的结点的个数if(bt){QueueInit(Q); QueueIn(Q,bt);//Q是以二叉树结点指针为元素的队列while(!QueueEmpty(Q)){p=QueueOut(Q); cout<<p->data;     //出队,访问结点if(p->lchild && !p->rchild ||!p->lchild && p->rchild)num++;//度为1的结点if(p->lchild) QueueIn(Q,p->lchild); //非空左子女入队if(p->rchild) QueueIn(Q,p->rchild); //非空右子女入队} //while(!QueueEmpty(Q))}//if(bt)return(num);}//返回度为1的结点的个数（7）求任意二叉树中第一条最长的路径长度，并输出此路径上各结点的值。[题目分析]因为后序遍历栈中保留当前结点的祖先的信息，用一变量保存栈的最高栈顶指针，每当退栈时，栈顶指针高于保存最高栈顶指针的值时，则将该栈倒入辅助栈中，辅助栈始终保存最长路径长度上的结点，直至后序遍历完毕，则辅助栈中内容即为所求。[算法描述]void LongestPath(BiTree bt)//求二叉树中的第一条最长路径长度{BiTree p=bt,l[],s[];//l, s是栈，元素是二叉树结点指针，l中保留当前最长路径中的结点int i，top=0,tag[],longest=0;while(p || top>0){while(p) {s[++top]=p；tag[top]=0; p=p->Lc;} //沿左分枝向下41if(tag[top]==1)    //当前结点的右分枝已遍历{if(!s[top]->Lc && !s[top]->Rc)  //只有到叶子结点时，才查看路径长度if(top>longest){for(i=1;i<=top;i++) l[i]=s[i]; longest=top; top--;}//保留当前最长路径到l栈，记住最高栈顶指针，退栈}else if(top>0) {tag[top]=1; p=s[top].Rc;}   //沿右子分枝向下}//while(p!=null||top>0)}//结束LongestPath（8）输出二叉树中从每个叶子结点到根结点的路径。[题目分析]采用先序遍历的递归方法，当找到叶子结点*b时，由于*b叶子结点尚未添加到path中，因此在输出路径时还需输出b->data值。[算法描述]void AllPath(BTNode *b,ElemType path[],int pathlen){int i;if (b!=NULL){if (b->lchild==NULL && b->rchild==NULL) //*b为叶子结点{cout << " " << b->data << "到根结点路径:" << b->data;for (i=pathlen-1;i>=0;i--)cout << endl;}else{path[pathlen]=b->data;//将当前结点放入路径中pathlen++;//路径长度增1AllPath(b->lchild,path,pathlen); //递归扫描左子树AllPath(b->rchild,path,pathlen); //递归扫描右子树pathlen--;//恢复环境}}//if (b!=NULL)}//算法结束第6章图421．选择题（1）在一个图中，所有顶点的度数之和等于图的边数的（）倍。A．1/2B．1C．2D．4答案：C（2）在一个有向图中，所有顶点的入度之和等于所有顶点的出度之和的（）倍。A．1/2B．1C．2D．4答案：B解释：有向图所有顶点入度之和等于所有顶点出度之和。（3）具有n个顶点的有向图最多有（）条边。A．n B．n(n-1)C．n(n+1) D．n2答案：B解释：有向图的边有方向之分，即为从n个顶点中选取2个顶点有序排列，结果为n(n-1)。（4）n个顶点的连通图用邻接距阵表示时，该距阵至少有（）个非零元素。A．n B．2(n-1)C．n/2D．n2答案：B（5）G是一个非连通无向图，共有28条边，则该图至少有（）个顶点。A．7 B．8C．9 D．10答案：C解释：8个顶点的无向图最多有8*7/2=28条边，再添加一个点即构成非连通无向图，故至少有9个顶点。（6）若从无向图的任意一个顶点出发进行一次深度优先搜索可以访问图中所有的顶点，则该图一定是（）图。A．非连通B．连通C．强连通D．有向答案：B解释：即从该无向图任意一个顶点出发有到各个顶点的路径，所以该无向图是连通图。（7）下面（）算法适合构造一个稠密图G的最小生成树。A．Prim算法B．Kruskal算法C．Floyd算法D．Dijkstra算法答案：A解释：Prim算法适合构造一个稠密图G的最小生成树，Kruskal算法适合构造一个稀疏图G的最小生成树。（8）用邻接表表示图进行广度优先遍历时，通常借助（）来实现算法。A．栈B.队列C.树D．图答案：B解释：广度优先遍历通常借助队列来实现算法，深度优先遍历通常借助栈来实现算法。（9）用邻接表表示图进行深度优先遍历时，通常借助（）来实现算法。A．栈B.队列C.树D．图答案：A43解释：广度优先遍历通常借助队列来实现算法，深度优先遍历通常借助栈来实现算法。（10）深度优先遍历类似于二叉树的（）。A．先序遍历B．中序遍历C．后序遍历D．层次遍历答案：A（11）广度优先遍历类似于二叉树的（）。A．先序遍历B．中序遍历C．后序遍历D．层次遍历答案：D（12）图的BFS生成树的树高比DFS生成树的树高（）。A．小B．相等C．小或相等D．大或相等答案：C解释：对于一些特殊的图，比如只有一个顶点的图，其BFS生成树的树高和DFS生成树的树高相等。一般的图，根据图的BFS生成树和DFS树的算法思想，BFS生成树的树高比DFS生成树的树高小。（13）已知图的邻接矩阵如图6.30所示，则从顶点v0出发按深度优先遍历的结果是（）。图6.30邻接矩阵（14）已知图的邻接表如图6.31所示，则从顶点v0出发按广度优先遍历的结果是（），按深度优先遍历的结果是（）。图6.31邻接表A．0 1 3 2答案：D、DB．0 2 3 1C．0 3 2 1D．0 1 2 3（15）下面（）方法可以判断出一个有向图是否有环。A．深度优先遍历B．拓扑排序C．求最短路径D．求关键路径答案：B2．应用题44（1）已知图6.32所示的有向图，请给出：①每个顶点的入度和出度；②邻接矩阵；③邻接表；④逆邻接表。图6.32有向图图6.33无向网答案：（2）已知如图6.33所示的无向网，请给出：①邻接矩阵；②邻接表；③最小生成树答案：45①③4345593555557654973632526546②abcdefg→→→→→→→baabbdd4435965→→→→→→→ccbcdef3555732→→→→→→ddefgh5→e95→h57→f6→g5→h4326（3）已知图的邻接矩阵如图6.34所示。试分别画出自顶点1出发进行遍历所得的深度优先生成树和广度优先生成树。（4）有向网如图6.35所示，试用迪杰斯特拉算法求出从顶点a到其他各顶点间的最短路径，完成表6.9。图6.28邻接矩阵46图6.34邻接矩阵图6.35有向网表6.9D终点bcdefgi=115(a,b)2(a,c)12(a,d)∞∞∞S终点集{a,c}{a,c,f}{a,c,f,e}i=215(a,b)12(a,d)10(a,c,e)6(a,c,f)∞i=315(a,b)11(a,c,f,d)10(a,c,e)16(a,c,f,g)i=415(a,b)11(a,c,f,d)16(a,c,f,g){a,c,f,e,d}i=515(a,b)14(a,c,f,d,g){a,c,f,e,d,g}{a,c,f,e,d,g,b}i=615(a,b)（5）试对图6.36所示的AOE-网：①求这个工程最早可能在什么时间结束；②求每个活动的最早开始时间和最迟开始时间；③确定哪些活动是关键活动47图6.36AOE-网答案：按拓扑有序的顺序计算各个顶点的最早可能开始时间Ve和最迟允许开始时间Vl。然后再计算各个活动的最早可能开始时间e和最迟允许开始时间l，根据l-e= 0?来确定关键活动，从而确定关键路径。1VeVl00<1, 2>el3．算法设计题（1）分别以邻接矩阵和邻接表作为存储结构，实现以下图的基本操作：①增加一个新顶点v，InsertVex(G, v)；②删除顶点v及其相关的边，DeleteVex(G,v);③增加一条边<v，w>，InsertArc(G,v,w);④删除一条边<v，w>，DeleteArc(G,v,w)。[算法描述]假设图G为有向无权图，以邻接矩阵作为存储结构四个算法分别如下：①增加一个新顶点vStatus Insert_Vex(MGraph &G, char v)//在邻接矩阵表示的图G上插入顶点v{if(G.vexnum+1)>MAX_VERTEX_NUM return INFEASIBLE;G.vexs[++G.vexnum]=v;return OK;}//Insert_Vex②删除顶点v及其相关的边，Status Delete_Vex(MGraph &G,char v)//在邻接矩阵表示的图G上删除顶点v{n=G.vexnum;if((m=LocateVex(G,v))<0) return ERROR;4821919<1, 3>00031515<3, 2>1515042937<2, 4>1927853838<2, 5>19190<3, 5>15271264343<4, 6>29378<5, 6>38380017-e17此工程最早完成时间为43。关键路径为<1, 3><3, 2><2, 5><5, 6>